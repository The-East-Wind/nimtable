/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Apache Iceberg REST Catalog API
 * Defines the specification for the first version of the REST Catalog API. Implementations should ideally support both Iceberg table specs v1 and v2, with priority given to v2.
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "{scheme}://{host}/{basePath}".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AddPartitionSpecUpdate
 */
export interface AddPartitionSpecUpdate {
    /**
     * 
     * @type {any}
     * @memberof AddPartitionSpecUpdate
     */
    action?: any;
    /**
     * 
     * @type {PartitionSpec}
     * @memberof AddPartitionSpecUpdate
     */
    spec: PartitionSpec;
}
/**
 * 
 * @export
 * @interface AddSchemaUpdate
 */
export interface AddSchemaUpdate {
    /**
     * 
     * @type {any}
     * @memberof AddSchemaUpdate
     */
    action?: any;
    /**
     * 
     * @type {Schema}
     * @memberof AddSchemaUpdate
     */
    schema: Schema;
    /**
     * This optional field is **DEPRECATED for REMOVAL** since it more safe to handle this internally, and shouldn't be exposed to the clients. The highest assigned column ID for the table. This is used to ensure columns are always assigned an unused ID when evolving schemas. When omitted, it will be computed on the server side.
     * @type {any}
     * @memberof AddSchemaUpdate
     */
    lastColumnId?: any;
}
/**
 * 
 * @export
 * @interface AddSnapshotUpdate
 */
export interface AddSnapshotUpdate {
    /**
     * 
     * @type {any}
     * @memberof AddSnapshotUpdate
     */
    action?: any;
    /**
     * 
     * @type {Snapshot}
     * @memberof AddSnapshotUpdate
     */
    snapshot: Snapshot;
}
/**
 * 
 * @export
 * @interface AddSortOrderUpdate
 */
export interface AddSortOrderUpdate {
    /**
     * 
     * @type {any}
     * @memberof AddSortOrderUpdate
     */
    action?: any;
    /**
     * 
     * @type {SortOrder}
     * @memberof AddSortOrderUpdate
     */
    sortOrder: SortOrder;
}
/**
 * 
 * @export
 * @interface AddViewVersionUpdate
 */
export interface AddViewVersionUpdate {
    /**
     * 
     * @type {any}
     * @memberof AddViewVersionUpdate
     */
    action?: any;
    /**
     * 
     * @type {ViewVersion}
     * @memberof AddViewVersionUpdate
     */
    viewVersion: ViewVersion;
}
/**
 * 
 * @export
 * @interface AndOrExpression
 */
export interface AndOrExpression {
    /**
     * 
     * @type {ExpressionType}
     * @memberof AndOrExpression
     */
    type: ExpressionType;
    /**
     * 
     * @type {Expression}
     * @memberof AndOrExpression
     */
    left: Expression;
    /**
     * 
     * @type {Expression}
     * @memberof AndOrExpression
     */
    right: Expression;
}
/**
 * The table must not already exist; used for create transactions
 * @export
 * @interface AssertCreate
 */
export interface AssertCreate {
    /**
     * 
     * @type {any}
     * @memberof AssertCreate
     */
    type: any;
}
/**
 * The table's current schema id must match the requirement's `current-schema-id`
 * @export
 * @interface AssertCurrentSchemaId
 */
export interface AssertCurrentSchemaId {
    /**
     * 
     * @type {any}
     * @memberof AssertCurrentSchemaId
     */
    type?: any;
    /**
     * 
     * @type {any}
     * @memberof AssertCurrentSchemaId
     */
    currentSchemaId: any;
}
/**
 * The table's default sort order id must match the requirement's `default-sort-order-id`
 * @export
 * @interface AssertDefaultSortOrderId
 */
export interface AssertDefaultSortOrderId {
    /**
     * 
     * @type {any}
     * @memberof AssertDefaultSortOrderId
     */
    type?: any;
    /**
     * 
     * @type {any}
     * @memberof AssertDefaultSortOrderId
     */
    defaultSortOrderId: any;
}
/**
 * The table's default spec id must match the requirement's `default-spec-id`
 * @export
 * @interface AssertDefaultSpecId
 */
export interface AssertDefaultSpecId {
    /**
     * 
     * @type {any}
     * @memberof AssertDefaultSpecId
     */
    type?: any;
    /**
     * 
     * @type {any}
     * @memberof AssertDefaultSpecId
     */
    defaultSpecId: any;
}
/**
 * The table's last assigned column id must match the requirement's `last-assigned-field-id`
 * @export
 * @interface AssertLastAssignedFieldId
 */
export interface AssertLastAssignedFieldId {
    /**
     * 
     * @type {any}
     * @memberof AssertLastAssignedFieldId
     */
    type?: any;
    /**
     * 
     * @type {any}
     * @memberof AssertLastAssignedFieldId
     */
    lastAssignedFieldId: any;
}
/**
 * The table's last assigned partition id must match the requirement's `last-assigned-partition-id`
 * @export
 * @interface AssertLastAssignedPartitionId
 */
export interface AssertLastAssignedPartitionId {
    /**
     * 
     * @type {any}
     * @memberof AssertLastAssignedPartitionId
     */
    type?: any;
    /**
     * 
     * @type {any}
     * @memberof AssertLastAssignedPartitionId
     */
    lastAssignedPartitionId: any;
}
/**
 * The table branch or tag identified by the requirement's `ref` must reference the requirement's `snapshot-id`; if `snapshot-id` is `null` or missing, the ref must not already exist
 * @export
 * @interface AssertRefSnapshotId
 */
export interface AssertRefSnapshotId {
    /**
     * 
     * @type {any}
     * @memberof AssertRefSnapshotId
     */
    type?: any;
    /**
     * 
     * @type {any}
     * @memberof AssertRefSnapshotId
     */
    ref: any;
    /**
     * 
     * @type {any}
     * @memberof AssertRefSnapshotId
     */
    snapshotId: any;
}
/**
 * The table UUID must match the requirement's `uuid`
 * @export
 * @interface AssertTableUUID
 */
export interface AssertTableUUID {
    /**
     * 
     * @type {any}
     * @memberof AssertTableUUID
     */
    type: any;
    /**
     * 
     * @type {any}
     * @memberof AssertTableUUID
     */
    uuid: any;
}
/**
 * The view UUID must match the requirement's `uuid`
 * @export
 * @interface AssertViewUUID
 */
export interface AssertViewUUID {
    /**
     * 
     * @type {any}
     * @memberof AssertViewUUID
     */
    type: any;
    /**
     * 
     * @type {any}
     * @memberof AssertViewUUID
     */
    uuid: any;
}
/**
 * Assigning a UUID to a table/view should only be done when creating the table/view. It is not safe to re-assign the UUID if a table/view already has a UUID assigned
 * @export
 * @interface AssignUUIDUpdate
 */
export interface AssignUUIDUpdate {
    /**
     * 
     * @type {any}
     * @memberof AssignUUIDUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof AssignUUIDUpdate
     */
    uuid: any;
}
/**
 * 
 * @export
 * @interface AsyncPlanningResult
 */
export interface AsyncPlanningResult {
    /**
     * 
     * @type {PlanStatus}
     * @memberof AsyncPlanningResult
     */
    status: PlanStatus;
    /**
     * ID used to track a planning request
     * @type {any}
     * @memberof AsyncPlanningResult
     */
    planId?: any;
}
/**
 * 
 * @export
 * @interface BaseUpdate
 */
export interface BaseUpdate {
    /**
     * 
     * @type {any}
     * @memberof BaseUpdate
     */
    action: any;
}
/**
 * Binary type values are stored and serialized as an uppercase hexadecimal string
 * @export
 */
export type BinaryTypeValue = any
/**
 * 
 * @export
 * @interface BlobMetadata
 */
export interface BlobMetadata {
    /**
     * 
     * @type {any}
     * @memberof BlobMetadata
     */
    type: any;
    /**
     * 
     * @type {any}
     * @memberof BlobMetadata
     */
    snapshotId: any;
    /**
     * 
     * @type {any}
     * @memberof BlobMetadata
     */
    sequenceNumber: any;
    /**
     * 
     * @type {any}
     * @memberof BlobMetadata
     */
    fields: any;
    /**
     * 
     * @type {any}
     * @memberof BlobMetadata
     */
    properties?: any;
}
/**
 * 
 * @export
 */
export type BooleanTypeValue = any
/**
 * Server-provided configuration for the catalog.
 * @export
 * @interface CatalogConfig
 */
export interface CatalogConfig {
    /**
     * Properties that should be used to override client configuration; applied after defaults and client configuration.
     * @type {any}
     * @memberof CatalogConfig
     */
    overrides: any;
    /**
     * Properties that should be used as default configuration; applied before client configuration.
     * @type {any}
     * @memberof CatalogConfig
     */
    defaults: any;
    /**
     * A list of endpoints that the server supports. The format of each endpoint must be \"<HTTP verb> <resource path from OpenAPI REST spec>\". The HTTP verb and the resource path must be separated by a space character.
     * @type {any}
     * @memberof CatalogConfig
     */
    endpoints?: any;
}
/**
 * 
 * @export
 * @interface CommitReport
 */
export interface CommitReport {
    /**
     * 
     * @type {any}
     * @memberof CommitReport
     */
    tableName: any;
    /**
     * 
     * @type {any}
     * @memberof CommitReport
     */
    snapshotId: any;
    /**
     * 
     * @type {any}
     * @memberof CommitReport
     */
    sequenceNumber: any;
    /**
     * 
     * @type {any}
     * @memberof CommitReport
     */
    operation: any;
    /**
     * 
     * @type {Metrics}
     * @memberof CommitReport
     */
    metrics: Metrics;
    /**
     * 
     * @type {any}
     * @memberof CommitReport
     */
    metadata?: any;
}
/**
 * 
 * @export
 * @interface CommitTableRequest
 */
export interface CommitTableRequest {
    /**
     * Table identifier to update; must be present for CommitTransactionRequest
     * @type {TableIdentifier}
     * @memberof CommitTableRequest
     */
    identifier?: TableIdentifier;
    /**
     * 
     * @type {any}
     * @memberof CommitTableRequest
     */
    requirements: any;
    /**
     * 
     * @type {any}
     * @memberof CommitTableRequest
     */
    updates: any;
}
/**
 * 
 * @export
 * @interface CommitTableResponse
 */
export interface CommitTableResponse {
    /**
     * 
     * @type {any}
     * @memberof CommitTableResponse
     */
    metadataLocation: any;
    /**
     * 
     * @type {TableMetadata}
     * @memberof CommitTableResponse
     */
    metadata: TableMetadata;
}
/**
 * 
 * @export
 * @interface CommitTransactionRequest
 */
export interface CommitTransactionRequest {
    /**
     * 
     * @type {any}
     * @memberof CommitTransactionRequest
     */
    tableChanges: any;
}
/**
 * 
 * @export
 * @interface CommitViewRequest
 */
export interface CommitViewRequest {
    /**
     * View identifier to update
     * @type {TableIdentifier}
     * @memberof CommitViewRequest
     */
    identifier?: TableIdentifier;
    /**
     * 
     * @type {any}
     * @memberof CommitViewRequest
     */
    requirements?: any;
    /**
     * 
     * @type {any}
     * @memberof CommitViewRequest
     */
    updates: any;
}
/**
 * Completed server-side planning result
 * @export
 */
export type CompletedPlanningResult = any
/**
 * 
 * @export
 */
export type CompletedPlanningWithIDResult = any
/**
 * 
 * @export
 * @interface ContentFile
 */
export interface ContentFile {
    /**
     * 
     * @type {any}
     * @memberof ContentFile
     */
    content: any;
    /**
     * 
     * @type {any}
     * @memberof ContentFile
     */
    filePath: any;
    /**
     * 
     * @type {FileFormat}
     * @memberof ContentFile
     */
    fileFormat: FileFormat;
    /**
     * 
     * @type {any}
     * @memberof ContentFile
     */
    specId: any;
    /**
     * A list of partition field values ordered based on the fields of the partition spec specified by the `spec-id`
     * @type {any}
     * @memberof ContentFile
     */
    partition: any;
    /**
     * Total file size in bytes
     * @type {any}
     * @memberof ContentFile
     */
    fileSizeInBytes: any;
    /**
     * Number of records in the file
     * @type {any}
     * @memberof ContentFile
     */
    recordCount: any;
    /**
     * Encryption key metadata blob
     * @type {any}
     * @memberof ContentFile
     */
    keyMetadata?: any;
    /**
     * List of splittable offsets
     * @type {any}
     * @memberof ContentFile
     */
    splitOffsets?: any;
    /**
     * 
     * @type {any}
     * @memberof ContentFile
     */
    sortOrderId?: any;
}
/**
 * 
 * @export
 * @interface CountMap
 */
export interface CountMap {
    /**
     * List of integer column ids for each corresponding value
     * @type {any}
     * @memberof CountMap
     */
    keys?: any;
    /**
     * List of Long values, matched to 'keys' by index
     * @type {any}
     * @memberof CountMap
     */
    values?: any;
}
/**
 * 
 * @export
 * @interface CounterResult
 */
export interface CounterResult {
    /**
     * 
     * @type {any}
     * @memberof CounterResult
     */
    unit: any;
    /**
     * 
     * @type {any}
     * @memberof CounterResult
     */
    value: any;
}
/**
 * 
 * @export
 * @interface CreateNamespaceRequest
 */
export interface CreateNamespaceRequest {
    /**
     * 
     * @type {Namespace}
     * @memberof CreateNamespaceRequest
     */
    namespace: Namespace;
    /**
     * Configured string to string map of properties for the namespace
     * @type {any}
     * @memberof CreateNamespaceRequest
     */
    properties?: any;
}
/**
 * 
 * @export
 * @interface CreateNamespaceResponse
 */
export interface CreateNamespaceResponse {
    /**
     * 
     * @type {Namespace}
     * @memberof CreateNamespaceResponse
     */
    namespace: Namespace;
    /**
     * Properties stored on the namespace, if supported by the server.
     * @type {any}
     * @memberof CreateNamespaceResponse
     */
    properties?: any;
}
/**
 * 
 * @export
 * @interface CreateTableRequest
 */
export interface CreateTableRequest {
    /**
     * 
     * @type {any}
     * @memberof CreateTableRequest
     */
    name: any;
    /**
     * 
     * @type {any}
     * @memberof CreateTableRequest
     */
    location?: any;
    /**
     * 
     * @type {Schema}
     * @memberof CreateTableRequest
     */
    schema: Schema;
    /**
     * 
     * @type {PartitionSpec}
     * @memberof CreateTableRequest
     */
    partitionSpec?: PartitionSpec;
    /**
     * 
     * @type {SortOrder}
     * @memberof CreateTableRequest
     */
    writeOrder?: SortOrder;
    /**
     * 
     * @type {any}
     * @memberof CreateTableRequest
     */
    stageCreate?: any;
    /**
     * 
     * @type {any}
     * @memberof CreateTableRequest
     */
    properties?: any;
}
/**
 * 
 * @export
 * @interface CreateViewRequest
 */
export interface CreateViewRequest {
    /**
     * 
     * @type {any}
     * @memberof CreateViewRequest
     */
    name: any;
    /**
     * 
     * @type {any}
     * @memberof CreateViewRequest
     */
    location?: any;
    /**
     * 
     * @type {Schema}
     * @memberof CreateViewRequest
     */
    schema: Schema;
    /**
     * The view version to create, will replace the schema-id sent within the view-version with the id assigned to the provided schema
     * @type {ViewVersion}
     * @memberof CreateViewRequest
     */
    viewVersion: ViewVersion;
    /**
     * 
     * @type {any}
     * @memberof CreateViewRequest
     */
    properties: any;
}
/**
 * 
 * @export
 * @interface DataFile
 */
export interface DataFile {
    /**
     * 
     * @type {any}
     * @memberof DataFile
     */
    content: any;
    /**
     * Map of column id to total count, including null and NaN
     * @type {any}
     * @memberof DataFile
     */
    columnSizes?: any;
    /**
     * Map of column id to null value count
     * @type {any}
     * @memberof DataFile
     */
    valueCounts?: any;
    /**
     * Map of column id to null value count
     * @type {any}
     * @memberof DataFile
     */
    nullValueCounts?: any;
    /**
     * Map of column id to number of NaN values in the column
     * @type {any}
     * @memberof DataFile
     */
    nanValueCounts?: any;
    /**
     * Map of column id to lower bound primitive type values
     * @type {any}
     * @memberof DataFile
     */
    lowerBounds?: any;
    /**
     * Map of column id to upper bound primitive type values
     * @type {any}
     * @memberof DataFile
     */
    upperBounds?: any;
}
/**
 * Date type values follow the 'YYYY-MM-DD' ISO-8601 standard date format
 * @export
 */
export type DateTypeValue = any
/**
 * Decimal type values are serialized as strings. Decimals with a positive scale serialize as numeric plain text, while decimals with a negative scale use scientific notation and the exponent will be equal to the negated scale. For instance, a decimal with a positive scale is '123.4500', with zero scale is '2', and with a negative scale is '2E+20'
 * @export
 */
export type DecimalTypeValue = any
/**
 * 
 * @export
 */
export type DeleteFile = any
/**
 * 
 * @export
 */
export type DoubleTypeValue = any
/**
 * Empty server-side planning result
 * @export
 * @interface EmptyPlanningResult
 */
export interface EmptyPlanningResult {
    /**
     * 
     * @type {PlanStatus}
     * @memberof EmptyPlanningResult
     */
    status: PlanStatus;
}
/**
 * 
 * @export
 * @interface EnableRowLineageUpdate
 */
export interface EnableRowLineageUpdate {
    /**
     * 
     * @type {any}
     * @memberof EnableRowLineageUpdate
     */
    action?: any;
}
/**
 * 
 * @export
 * @interface EqualityDeleteFile
 */
export interface EqualityDeleteFile {
    /**
     * 
     * @type {any}
     * @memberof EqualityDeleteFile
     */
    content: any;
    /**
     * List of equality field IDs
     * @type {any}
     * @memberof EqualityDeleteFile
     */
    equalityIds?: any;
}
/**
 * JSON error payload returned in a response with further details on the error
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * Human-readable error message
     * @type {any}
     * @memberof ErrorModel
     */
    message: any;
    /**
     * Internal type definition of the error
     * @type {any}
     * @memberof ErrorModel
     */
    type: any;
    /**
     * HTTP response code
     * @type {any}
     * @memberof ErrorModel
     */
    code: any;
    /**
     * 
     * @type {any}
     * @memberof ErrorModel
     */
    stack?: any;
}
/**
 * 
 * @export
 */
export type Expression = any
/**
 * 
 * @export
 */
export type ExpressionType = any
/**
 * Failed server-side planning result
 * @export
 */
export type FailedPlanningResult = any
/**
 * 
 * @export
 * @interface FalseExpression
 */
export interface FalseExpression {
    /**
     * 
     * @type {ExpressionType}
     * @memberof FalseExpression
     */
    type: ExpressionType;
}
/**
 * Result of server-side scan planning for fetchPlanningResult
 * @export
 */
export type FetchPlanningResult = any
/**
 * 
 * @export
 * @interface FetchScanTasksRequest
 */
export interface FetchScanTasksRequest {
    /**
     * 
     * @type {PlanTask}
     * @memberof FetchScanTasksRequest
     */
    planTask: PlanTask;
}
/**
 * Response schema for fetchScanTasks
 * @export
 */
export type FetchScanTasksResult = any
/**
 * A full field name (including parent field names), such as those passed in APIs like Java `Schema#findField(String name)`. The nested field name follows these rules - Nested struct fields are named by concatenating field names at each struct level using dot (`.`) delimiter, e.g. employer.contact_info.address.zip_code - Nested fields in a map key are named using the keyword `key`, e.g. employee_address_map.key.first_name - Nested fields in a map value are named using the keyword `value`, e.g. employee_address_map.value.zip_code - Nested fields in a list are named using the keyword `element`, e.g. employees.element.first_name
 * @export
 */
export type FieldName = any
/**
 * 
 * @export
 * @enum {string}
 */
export enum FileFormat {
    Avro = <any> 'avro',
    Orc = <any> 'orc',
    Parquet = <any> 'parquet',
    Puffin = <any> 'puffin'
}
/**
 * 
 * @export
 * @interface FileScanTask
 */
export interface FileScanTask {
    /**
     * 
     * @type {DataFile}
     * @memberof FileScanTask
     */
    dataFile: DataFile;
    /**
     * A list of indices in the delete files array (0-based)
     * @type {any}
     * @memberof FileScanTask
     */
    deleteFileReferences?: any;
    /**
     * An optional filter to be applied to rows in this file scan task. If the residual is not present, the client must produce the residual or use the original filter.
     * @type {any}
     * @memberof FileScanTask
     */
    residualFilter?: any;
}
/**
 * Fixed length type values are stored and serialized as an uppercase hexadecimal string preserving the fixed length
 * @export
 */
export type FixedTypeValue = any
/**
 * 
 * @export
 */
export type FloatTypeValue = any
/**
 * 
 * @export
 * @interface GetNamespaceResponse
 */
export interface GetNamespaceResponse {
    /**
     * 
     * @type {Namespace}
     * @memberof GetNamespaceResponse
     */
    namespace: Namespace;
    /**
     * Properties stored on the namespace, if supported by the server. If the server does not support namespace properties, it should return null for this field. If namespace properties are supported, but none are set, it should return an empty object.
     * @type {any}
     * @memberof GetNamespaceResponse
     */
    properties?: any;
}
/**
 * JSON wrapper for all error responses (non-2xx)
 * @export
 * @interface IcebergErrorResponse
 */
export interface IcebergErrorResponse {
    /**
     * 
     * @type {ErrorModel}
     * @memberof IcebergErrorResponse
     */
    error: ErrorModel;
}
/**
 * 
 * @export
 */
export type IntegerTypeValue = any
/**
 * 
 * @export
 * @interface ListNamespacesResponse
 */
export interface ListNamespacesResponse {
    /**
     * 
     * @type {PageToken}
     * @memberof ListNamespacesResponse
     */
    nextPageToken?: PageToken;
    /**
     * 
     * @type {any}
     * @memberof ListNamespacesResponse
     */
    namespaces?: any;
}
/**
 * 
 * @export
 * @interface ListTablesResponse
 */
export interface ListTablesResponse {
    /**
     * 
     * @type {PageToken}
     * @memberof ListTablesResponse
     */
    nextPageToken?: PageToken;
    /**
     * 
     * @type {any}
     * @memberof ListTablesResponse
     */
    identifiers?: any;
}
/**
 * 
 * @export
 * @interface ListType
 */
export interface ListType {
    /**
     * 
     * @type {any}
     * @memberof ListType
     */
    type: any;
    /**
     * 
     * @type {any}
     * @memberof ListType
     */
    elementId: any;
    /**
     * 
     * @type {Type}
     * @memberof ListType
     */
    element: Type;
    /**
     * 
     * @type {any}
     * @memberof ListType
     */
    elementRequired: any;
}
/**
 * 
 * @export
 * @interface LiteralExpression
 */
export interface LiteralExpression {
    /**
     * 
     * @type {ExpressionType}
     * @memberof LiteralExpression
     */
    type: ExpressionType;
    /**
     * 
     * @type {Term}
     * @memberof LiteralExpression
     */
    term: Term;
    /**
     * 
     * @type {any}
     * @memberof LiteralExpression
     */
    value: any;
}
/**
 * 
 * @export
 * @interface LoadCredentialsResponse
 */
export interface LoadCredentialsResponse {
    /**
     * 
     * @type {any}
     * @memberof LoadCredentialsResponse
     */
    storageCredentials: any;
}
/**
 * Result used when a table is successfully loaded.   The table metadata JSON is returned in the `metadata` field. The corresponding file location of table metadata should be returned in the `metadata-location` field, unless the metadata is not yet committed. For example, a create transaction may return metadata that is staged but not committed. Clients can check whether metadata has changed by comparing metadata locations after the table has been created.   The `config` map returns table-specific configuration for the table's resources, including its HTTP client and FileIO. For example, config may contain a specific FileIO implementation class for the table depending on its underlying storage.   The following configurations should be respected by clients:  ## General Configurations  - `token`: Authorization bearer token to use for table requests if OAuth2 security is enabled   ## AWS Configurations  The following configurations should be respected when working with tables stored in AWS S3  - `client.region`: region to configure client for making requests to AWS  - `s3.access-key-id`: id for credentials that provide access to the data in S3  - `s3.secret-access-key`: secret for credentials that provide access to data in S3   - `s3.session-token`: if present, this value should be used for as the session token   - `s3.remote-signing-enabled`: if `true` remote signing should be performed as described in the `s3-signer-open-api.yaml` specification  - `s3.cross-region-access-enabled`: if `true`, S3 Cross-Region bucket access is enabled  ## Storage Credentials  Credentials for ADLS / GCS / S3 / ... are provided through the `storage-credentials` field. Clients must first check whether the respective credentials exist in the `storage-credentials` field before checking the `config` for credentials. 
 * @export
 * @interface LoadTableResult
 */
export interface LoadTableResult {
    /**
     * May be null if the table is staged as part of a transaction
     * @type {any}
     * @memberof LoadTableResult
     */
    metadataLocation?: any;
    /**
     * 
     * @type {TableMetadata}
     * @memberof LoadTableResult
     */
    metadata: TableMetadata;
    /**
     * 
     * @type {any}
     * @memberof LoadTableResult
     */
    config?: any;
    /**
     * 
     * @type {any}
     * @memberof LoadTableResult
     */
    storageCredentials?: any;
}
/**
 * Result used when a view is successfully loaded.   The view metadata JSON is returned in the `metadata` field. The corresponding file location of view metadata is returned in the `metadata-location` field. Clients can check whether metadata has changed by comparing metadata locations after the view has been created.  The `config` map returns view-specific configuration for the view's resources.  The following configurations should be respected by clients:  ## General Configurations  - `token`: Authorization bearer token to use for view requests if OAuth2 security is enabled 
 * @export
 * @interface LoadViewResult
 */
export interface LoadViewResult {
    /**
     * 
     * @type {any}
     * @memberof LoadViewResult
     */
    metadataLocation: any;
    /**
     * 
     * @type {ViewMetadata}
     * @memberof LoadViewResult
     */
    metadata: ViewMetadata;
    /**
     * 
     * @type {any}
     * @memberof LoadViewResult
     */
    config?: any;
}
/**
 * 
 * @export
 */
export type LongTypeValue = any
/**
 * 
 * @export
 * @interface MapType
 */
export interface MapType {
    /**
     * 
     * @type {any}
     * @memberof MapType
     */
    type: any;
    /**
     * 
     * @type {any}
     * @memberof MapType
     */
    keyId: any;
    /**
     * 
     * @type {Type}
     * @memberof MapType
     */
    key: Type;
    /**
     * 
     * @type {any}
     * @memberof MapType
     */
    valueId: any;
    /**
     * 
     * @type {Type}
     * @memberof MapType
     */
    value: Type;
    /**
     * 
     * @type {any}
     * @memberof MapType
     */
    valueRequired: any;
}
/**
 * 
 * @export
 */
export type MetadataLog = any
/**
 * 
 * @export
 */
export type MetricResult = any
/**
 * 
 * @export
 */
export type Metrics = any
/**
 * Reference to one or more levels of a namespace
 * @export
 */
export type Namespace = any
/**
 * 
 * @export
 * @interface NotExpression
 */
export interface NotExpression {
    /**
     * 
     * @type {ExpressionType}
     * @memberof NotExpression
     */
    type: ExpressionType;
    /**
     * 
     * @type {Expression}
     * @memberof NotExpression
     */
    child: Expression;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum NullOrder {
    First = <any> 'nulls-first',
    Last = <any> 'nulls-last'
}
/**
 * The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.  OAuth2 client credentials request  See https://datatracker.ietf.org/doc/html/rfc6749#section-4.4
 * @export
 * @interface OAuthClientCredentialsRequest
 */
export interface OAuthClientCredentialsRequest {
    /**
     * 
     * @type {any}
     * @memberof OAuthClientCredentialsRequest
     */
    grantType: any;
    /**
     * 
     * @type {any}
     * @memberof OAuthClientCredentialsRequest
     */
    scope?: any;
    /**
     * Client ID  This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.
     * @type {any}
     * @memberof OAuthClientCredentialsRequest
     */
    clientId: any;
    /**
     * Client secret  This can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.
     * @type {any}
     * @memberof OAuthClientCredentialsRequest
     */
    clientSecret: any;
}
/**
 * The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
 * @export
 * @interface OAuthError
 */
export interface OAuthError {
    /**
     * 
     * @type {any}
     * @memberof OAuthError
     */
    error: any;
    /**
     * 
     * @type {any}
     * @memberof OAuthError
     */
    errorDescription?: any;
    /**
     * 
     * @type {any}
     * @memberof OAuthError
     */
    errorUri?: any;
}
/**
 * The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.  OAuth2 token exchange request  See https://datatracker.ietf.org/doc/html/rfc8693
 * @export
 * @interface OAuthTokenExchangeRequest
 */
export interface OAuthTokenExchangeRequest {
    /**
     * 
     * @type {any}
     * @memberof OAuthTokenExchangeRequest
     */
    grantType: any;
    /**
     * 
     * @type {any}
     * @memberof OAuthTokenExchangeRequest
     */
    scope?: any;
    /**
     * 
     * @type {TokenType}
     * @memberof OAuthTokenExchangeRequest
     */
    requestedTokenType?: TokenType;
    /**
     * Subject token for token exchange request
     * @type {any}
     * @memberof OAuthTokenExchangeRequest
     */
    subjectToken: any;
    /**
     * 
     * @type {TokenType}
     * @memberof OAuthTokenExchangeRequest
     */
    subjectTokenType: TokenType;
    /**
     * Actor token for token exchange request
     * @type {any}
     * @memberof OAuthTokenExchangeRequest
     */
    actorToken?: any;
    /**
     * 
     * @type {TokenType}
     * @memberof OAuthTokenExchangeRequest
     */
    actorTokenType?: TokenType;
}
/**
 * The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
 * @export
 */
export type OAuthTokenRequest = any
/**
 * The `oauth/tokens` endpoint and related schemas are **DEPRECATED for REMOVAL** from this spec, see description of the endpoint.
 * @export
 * @interface OAuthTokenResponse
 */
export interface OAuthTokenResponse {
    /**
     * The access token, for client credentials or token exchange
     * @type {any}
     * @memberof OAuthTokenResponse
     */
    accessToken: any;
    /**
     * Access token type for client credentials or token exchange  See https://datatracker.ietf.org/doc/html/rfc6749#section-7.1
     * @type {any}
     * @memberof OAuthTokenResponse
     */
    tokenType: any;
    /**
     * Lifetime of the access token in seconds for client credentials or token exchange
     * @type {any}
     * @memberof OAuthTokenResponse
     */
    expiresIn?: any;
    /**
     * 
     * @type {TokenType}
     * @memberof OAuthTokenResponse
     */
    issuedTokenType?: TokenType;
    /**
     * Refresh token for client credentials or token exchange
     * @type {any}
     * @memberof OAuthTokenResponse
     */
    refreshToken?: any;
    /**
     * Authorization scope for client credentials or token exchange
     * @type {any}
     * @memberof OAuthTokenResponse
     */
    scope?: any;
}
/**
 * An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server. Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available.  After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response. Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request. Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response. Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results.
 * @export
 */
export type PageToken = any
/**
 * 
 * @export
 * @interface PartitionField
 */
export interface PartitionField {
    /**
     * 
     * @type {any}
     * @memberof PartitionField
     */
    fieldId?: any;
    /**
     * 
     * @type {any}
     * @memberof PartitionField
     */
    sourceId: any;
    /**
     * 
     * @type {any}
     * @memberof PartitionField
     */
    name: any;
    /**
     * 
     * @type {Transform}
     * @memberof PartitionField
     */
    transform: Transform;
}
/**
 * 
 * @export
 * @interface PartitionSpec
 */
export interface PartitionSpec {
    /**
     * 
     * @type {any}
     * @memberof PartitionSpec
     */
    specId?: any;
    /**
     * 
     * @type {any}
     * @memberof PartitionSpec
     */
    fields: any;
}
/**
 * 
 * @export
 * @interface PartitionStatisticsFile
 */
export interface PartitionStatisticsFile {
    /**
     * 
     * @type {any}
     * @memberof PartitionStatisticsFile
     */
    snapshotId: any;
    /**
     * 
     * @type {any}
     * @memberof PartitionStatisticsFile
     */
    statisticsPath: any;
    /**
     * 
     * @type {any}
     * @memberof PartitionStatisticsFile
     */
    fileSizeInBytes: any;
}
/**
 * Status of a server-side planning operation
 * @export
 * @enum {string}
 */
export enum PlanStatus {
    Completed = <any> 'completed',
    Submitted = <any> 'submitted',
    Cancelled = <any> 'cancelled',
    Failed = <any> 'failed'
}
/**
 * 
 * @export
 * @interface PlanTableScanRequest
 */
export interface PlanTableScanRequest {
    /**
     * Identifier for the snapshot to scan in a point-in-time scan
     * @type {any}
     * @memberof PlanTableScanRequest
     */
    snapshotId?: any;
    /**
     * List of selected schema fields
     * @type {any}
     * @memberof PlanTableScanRequest
     */
    select?: any;
    /**
     * Expression used to filter the table data
     * @type {Expression}
     * @memberof PlanTableScanRequest
     */
    filter?: Expression;
    /**
     * Enables case sensitive field matching for filter and select
     * @type {any}
     * @memberof PlanTableScanRequest
     */
    caseSensitive?: any;
    /**
     * Whether to use the schema at the time the snapshot was written. When time travelling, the snapshot schema should be used (true). When scanning a branch, the table schema should be used (false).
     * @type {any}
     * @memberof PlanTableScanRequest
     */
    useSnapshotSchema?: any;
    /**
     * Starting snapshot ID for an incremental scan (exclusive)
     * @type {any}
     * @memberof PlanTableScanRequest
     */
    startSnapshotId?: any;
    /**
     * Ending snapshot ID for an incremental scan (inclusive). Required when start-snapshot-id is specified.
     * @type {any}
     * @memberof PlanTableScanRequest
     */
    endSnapshotId?: any;
    /**
     * List of fields for which the service should send column stats.
     * @type {any}
     * @memberof PlanTableScanRequest
     */
    statsFields?: any;
}
/**
 * Result of server-side scan planning for planTableScan
 * @export
 */
export type PlanTableScanResult = any
/**
 * An opaque string provided by the REST server that represents a unit of work to produce file scan tasks for scan planning. This allows clients to fetch tasks across multiple requests to accommodate large result sets.
 * @export
 */
export type PlanTask = any
/**
 * 
 * @export
 * @interface PositionDeleteFile
 */
export interface PositionDeleteFile {
    /**
     * 
     * @type {any}
     * @memberof PositionDeleteFile
     */
    content: any;
    /**
     * Offset within the delete file of delete content
     * @type {any}
     * @memberof PositionDeleteFile
     */
    contentOffset?: any;
    /**
     * Length, in bytes, of the delete content; required if content-offset is present
     * @type {any}
     * @memberof PositionDeleteFile
     */
    contentSizeInBytes?: any;
}
/**
 * 
 * @export
 */
export type PrimitiveType = any
/**
 * 
 * @export
 */
export type PrimitiveTypeValue = any
/**
 * 
 * @export
 */
export type Reference = any
/**
 * 
 * @export
 * @interface RegisterTableRequest
 */
export interface RegisterTableRequest {
    /**
     * 
     * @type {any}
     * @memberof RegisterTableRequest
     */
    name: any;
    /**
     * 
     * @type {any}
     * @memberof RegisterTableRequest
     */
    metadataLocation: any;
}
/**
 * 
 * @export
 * @interface RemovePartitionSpecsUpdate
 */
export interface RemovePartitionSpecsUpdate {
    /**
     * 
     * @type {any}
     * @memberof RemovePartitionSpecsUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof RemovePartitionSpecsUpdate
     */
    specIds: any;
}
/**
 * 
 * @export
 * @interface RemovePartitionStatisticsUpdate
 */
export interface RemovePartitionStatisticsUpdate {
    /**
     * 
     * @type {any}
     * @memberof RemovePartitionStatisticsUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof RemovePartitionStatisticsUpdate
     */
    snapshotId: any;
}
/**
 * 
 * @export
 * @interface RemovePropertiesUpdate
 */
export interface RemovePropertiesUpdate {
    /**
     * 
     * @type {any}
     * @memberof RemovePropertiesUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof RemovePropertiesUpdate
     */
    removals: any;
}
/**
 * 
 * @export
 * @interface RemoveSchemasUpdate
 */
export interface RemoveSchemasUpdate {
    /**
     * 
     * @type {any}
     * @memberof RemoveSchemasUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof RemoveSchemasUpdate
     */
    schemaIds: any;
}
/**
 * 
 * @export
 * @interface RemoveSnapshotRefUpdate
 */
export interface RemoveSnapshotRefUpdate {
    /**
     * 
     * @type {any}
     * @memberof RemoveSnapshotRefUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof RemoveSnapshotRefUpdate
     */
    refName: any;
}
/**
 * 
 * @export
 * @interface RemoveSnapshotsUpdate
 */
export interface RemoveSnapshotsUpdate {
    /**
     * 
     * @type {any}
     * @memberof RemoveSnapshotsUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof RemoveSnapshotsUpdate
     */
    snapshotIds: any;
}
/**
 * 
 * @export
 * @interface RemoveStatisticsUpdate
 */
export interface RemoveStatisticsUpdate {
    /**
     * 
     * @type {any}
     * @memberof RemoveStatisticsUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof RemoveStatisticsUpdate
     */
    snapshotId: any;
}
/**
 * 
 * @export
 * @interface RenameTableRequest
 */
export interface RenameTableRequest {
    /**
     * 
     * @type {TableIdentifier}
     * @memberof RenameTableRequest
     */
    source: TableIdentifier;
    /**
     * 
     * @type {TableIdentifier}
     * @memberof RenameTableRequest
     */
    destination: TableIdentifier;
}
/**
 * 
 * @export
 * @interface ReportMetricsRequest
 */
export interface ReportMetricsRequest {
    /**
     * 
     * @type {any}
     * @memberof ReportMetricsRequest
     */
    reportType: any;
}
/**
 * 
 * @export
 * @interface SQLViewRepresentation
 */
export interface SQLViewRepresentation {
    /**
     * 
     * @type {any}
     * @memberof SQLViewRepresentation
     */
    type: any;
    /**
     * 
     * @type {any}
     * @memberof SQLViewRepresentation
     */
    sql: any;
    /**
     * 
     * @type {any}
     * @memberof SQLViewRepresentation
     */
    dialect: any;
}
/**
 * 
 * @export
 * @interface ScanReport
 */
export interface ScanReport {
    /**
     * 
     * @type {any}
     * @memberof ScanReport
     */
    tableName: any;
    /**
     * 
     * @type {any}
     * @memberof ScanReport
     */
    snapshotId: any;
    /**
     * 
     * @type {Expression}
     * @memberof ScanReport
     */
    filter: Expression;
    /**
     * 
     * @type {any}
     * @memberof ScanReport
     */
    schemaId: any;
    /**
     * 
     * @type {any}
     * @memberof ScanReport
     */
    projectedFieldIds: any;
    /**
     * 
     * @type {any}
     * @memberof ScanReport
     */
    projectedFieldNames: any;
    /**
     * 
     * @type {Metrics}
     * @memberof ScanReport
     */
    metrics: Metrics;
    /**
     * 
     * @type {any}
     * @memberof ScanReport
     */
    metadata?: any;
}
/**
 * Scan and planning tasks for server-side scan planning  - `plan-tasks` contains opaque units of planning work - `file-scan-tasks` contains a partial or complete list of table scan tasks - `delete-files` contains delete files referenced by file scan tasks  Each plan task must be passed to the fetchScanTasks endpoint to fetch the file scan tasks for the plan task.  The list of delete files must contain all delete files referenced by the file scan tasks. 
 * @export
 * @interface ScanTasks
 */
export interface ScanTasks {
    /**
     * Delete files referenced by file scan tasks
     * @type {any}
     * @memberof ScanTasks
     */
    deleteFiles?: any;
    /**
     * 
     * @type {any}
     * @memberof ScanTasks
     */
    fileScanTasks?: any;
    /**
     * 
     * @type {any}
     * @memberof ScanTasks
     */
    planTasks?: any;
}
/**
 * 
 * @export
 */
export type Schema = any
/**
 * 
 * @export
 * @interface SetCurrentSchemaUpdate
 */
export interface SetCurrentSchemaUpdate {
    /**
     * 
     * @type {any}
     * @memberof SetCurrentSchemaUpdate
     */
    action?: any;
    /**
     * Schema ID to set as current, or -1 to set last added schema
     * @type {any}
     * @memberof SetCurrentSchemaUpdate
     */
    schemaId: any;
}
/**
 * 
 * @export
 * @interface SetCurrentViewVersionUpdate
 */
export interface SetCurrentViewVersionUpdate {
    /**
     * 
     * @type {any}
     * @memberof SetCurrentViewVersionUpdate
     */
    action?: any;
    /**
     * The view version id to set as current, or -1 to set last added view version id
     * @type {any}
     * @memberof SetCurrentViewVersionUpdate
     */
    viewVersionId: any;
}
/**
 * 
 * @export
 * @interface SetDefaultSortOrderUpdate
 */
export interface SetDefaultSortOrderUpdate {
    /**
     * 
     * @type {any}
     * @memberof SetDefaultSortOrderUpdate
     */
    action?: any;
    /**
     * Sort order ID to set as the default, or -1 to set last added sort order
     * @type {any}
     * @memberof SetDefaultSortOrderUpdate
     */
    sortOrderId: any;
}
/**
 * 
 * @export
 * @interface SetDefaultSpecUpdate
 */
export interface SetDefaultSpecUpdate {
    /**
     * 
     * @type {any}
     * @memberof SetDefaultSpecUpdate
     */
    action?: any;
    /**
     * Partition spec ID to set as the default, or -1 to set last added spec
     * @type {any}
     * @memberof SetDefaultSpecUpdate
     */
    specId: any;
}
/**
 * 
 * @export
 * @interface SetExpression
 */
export interface SetExpression {
    /**
     * 
     * @type {ExpressionType}
     * @memberof SetExpression
     */
    type: ExpressionType;
    /**
     * 
     * @type {Term}
     * @memberof SetExpression
     */
    term: Term;
    /**
     * 
     * @type {any}
     * @memberof SetExpression
     */
    values: any;
}
/**
 * 
 * @export
 * @interface SetLocationUpdate
 */
export interface SetLocationUpdate {
    /**
     * 
     * @type {any}
     * @memberof SetLocationUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof SetLocationUpdate
     */
    location: any;
}
/**
 * 
 * @export
 * @interface SetPartitionStatisticsUpdate
 */
export interface SetPartitionStatisticsUpdate {
    /**
     * 
     * @type {any}
     * @memberof SetPartitionStatisticsUpdate
     */
    action?: any;
    /**
     * 
     * @type {PartitionStatisticsFile}
     * @memberof SetPartitionStatisticsUpdate
     */
    partitionStatistics: PartitionStatisticsFile;
}
/**
 * 
 * @export
 * @interface SetPropertiesUpdate
 */
export interface SetPropertiesUpdate {
    /**
     * 
     * @type {any}
     * @memberof SetPropertiesUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof SetPropertiesUpdate
     */
    updates: any;
}
/**
 * 
 * @export
 * @interface SetSnapshotRefUpdate
 */
export interface SetSnapshotRefUpdate {
    /**
     * 
     * @type {any}
     * @memberof SetSnapshotRefUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof SetSnapshotRefUpdate
     */
    refName: any;
}
/**
 * 
 * @export
 * @interface SetStatisticsUpdate
 */
export interface SetStatisticsUpdate {
    /**
     * 
     * @type {any}
     * @memberof SetStatisticsUpdate
     */
    action?: any;
    /**
     * This optional field is **DEPRECATED for REMOVAL** since it contains redundant information. Clients should use the `statistics.snapshot-id` field instead.
     * @type {any}
     * @memberof SetStatisticsUpdate
     */
    snapshotId?: any;
    /**
     * 
     * @type {StatisticsFile}
     * @memberof SetStatisticsUpdate
     */
    statistics: StatisticsFile;
}
/**
 * 
 * @export
 * @interface Snapshot
 */
export interface Snapshot {
    /**
     * 
     * @type {any}
     * @memberof Snapshot
     */
    snapshotId: any;
    /**
     * 
     * @type {any}
     * @memberof Snapshot
     */
    parentSnapshotId?: any;
    /**
     * 
     * @type {any}
     * @memberof Snapshot
     */
    sequenceNumber?: any;
    /**
     * 
     * @type {any}
     * @memberof Snapshot
     */
    timestampMs: any;
    /**
     * Location of the snapshot's manifest list file
     * @type {any}
     * @memberof Snapshot
     */
    manifestList: any;
    /**
     * 
     * @type {SnapshotSummary}
     * @memberof Snapshot
     */
    summary: SnapshotSummary;
    /**
     * 
     * @type {any}
     * @memberof Snapshot
     */
    schemaId?: any;
}
/**
 * 
 * @export
 */
export type SnapshotLog = any
/**
 * 
 * @export
 * @interface SnapshotReference
 */
export interface SnapshotReference {
    /**
     * 
     * @type {any}
     * @memberof SnapshotReference
     */
    type: any;
    /**
     * 
     * @type {any}
     * @memberof SnapshotReference
     */
    snapshotId: any;
    /**
     * 
     * @type {any}
     * @memberof SnapshotReference
     */
    maxRefAgeMs?: any;
    /**
     * 
     * @type {any}
     * @memberof SnapshotReference
     */
    maxSnapshotAgeMs?: any;
    /**
     * 
     * @type {any}
     * @memberof SnapshotReference
     */
    minSnapshotsToKeep?: any;
}
/**
 * 
 * @export
 */
export type SnapshotReferences = any
/**
 * 
 * @export
 * @interface SnapshotSummary
 */
export interface SnapshotSummary {
    /**
     * 
     * @type {any}
     * @memberof SnapshotSummary
     */
    operation: any;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SortDirection {
    Asc = <any> 'asc',
    Desc = <any> 'desc'
}
/**
 * 
 * @export
 * @interface SortField
 */
export interface SortField {
    /**
     * 
     * @type {any}
     * @memberof SortField
     */
    sourceId: any;
    /**
     * 
     * @type {Transform}
     * @memberof SortField
     */
    transform: Transform;
    /**
     * 
     * @type {SortDirection}
     * @memberof SortField
     */
    direction: SortDirection;
    /**
     * 
     * @type {NullOrder}
     * @memberof SortField
     */
    nullOrder: NullOrder;
}
/**
 * 
 * @export
 * @interface SortOrder
 */
export interface SortOrder {
    /**
     * 
     * @type {any}
     * @memberof SortOrder
     */
    orderId: any;
    /**
     * 
     * @type {any}
     * @memberof SortOrder
     */
    fields: any;
}
/**
 * 
 * @export
 * @interface StatisticsFile
 */
export interface StatisticsFile {
    /**
     * 
     * @type {any}
     * @memberof StatisticsFile
     */
    snapshotId: any;
    /**
     * 
     * @type {any}
     * @memberof StatisticsFile
     */
    statisticsPath: any;
    /**
     * 
     * @type {any}
     * @memberof StatisticsFile
     */
    fileSizeInBytes: any;
    /**
     * 
     * @type {any}
     * @memberof StatisticsFile
     */
    fileFooterSizeInBytes: any;
    /**
     * 
     * @type {any}
     * @memberof StatisticsFile
     */
    blobMetadata: any;
}
/**
 * 
 * @export
 * @interface StorageCredential
 */
export interface StorageCredential {
    /**
     * Indicates a storage location prefix where the credential is relevant. Clients should choose the most specific prefix (by selecting the longest prefix) if several credentials of the same type are available.
     * @type {any}
     * @memberof StorageCredential
     */
    prefix: any;
    /**
     * 
     * @type {any}
     * @memberof StorageCredential
     */
    config: any;
}
/**
 * 
 * @export
 */
export type StringTypeValue = any
/**
 * 
 * @export
 * @interface StructField
 */
export interface StructField {
    /**
     * 
     * @type {any}
     * @memberof StructField
     */
    id: any;
    /**
     * 
     * @type {any}
     * @memberof StructField
     */
    name: any;
    /**
     * 
     * @type {Type}
     * @memberof StructField
     */
    type: Type;
    /**
     * 
     * @type {any}
     * @memberof StructField
     */
    required: any;
    /**
     * 
     * @type {any}
     * @memberof StructField
     */
    doc?: any;
    /**
     * 
     * @type {PrimitiveTypeValue}
     * @memberof StructField
     */
    initialDefault?: PrimitiveTypeValue;
    /**
     * 
     * @type {PrimitiveTypeValue}
     * @memberof StructField
     */
    writeDefault?: PrimitiveTypeValue;
}
/**
 * 
 * @export
 * @interface StructType
 */
export interface StructType {
    /**
     * 
     * @type {any}
     * @memberof StructType
     */
    type: any;
    /**
     * 
     * @type {any}
     * @memberof StructType
     */
    fields: any;
}
/**
 * 
 * @export
 * @interface TableIdentifier
 */
export interface TableIdentifier {
    /**
     * 
     * @type {Namespace}
     * @memberof TableIdentifier
     */
    namespace: Namespace;
    /**
     * 
     * @type {any}
     * @memberof TableIdentifier
     */
    name: any;
}
/**
 * 
 * @export
 * @interface TableMetadata
 */
export interface TableMetadata {
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    formatVersion: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    tableUuid: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    location?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    lastUpdatedMs?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    properties?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    schemas?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    currentSchemaId?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    lastColumnId?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    partitionSpecs?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    defaultSpecId?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    lastPartitionId?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    sortOrders?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    defaultSortOrderId?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    snapshots?: any;
    /**
     * 
     * @type {SnapshotReferences}
     * @memberof TableMetadata
     */
    refs?: SnapshotReferences;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    currentSnapshotId?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    lastSequenceNumber?: any;
    /**
     * 
     * @type {SnapshotLog}
     * @memberof TableMetadata
     */
    snapshotLog?: SnapshotLog;
    /**
     * 
     * @type {MetadataLog}
     * @memberof TableMetadata
     */
    metadataLog?: MetadataLog;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    statistics?: any;
    /**
     * 
     * @type {any}
     * @memberof TableMetadata
     */
    partitionStatistics?: any;
}
/**
 * 
 * @export
 * @interface TableRequirement
 */
export interface TableRequirement {
    /**
     * 
     * @type {any}
     * @memberof TableRequirement
     */
    type: any;
}
/**
 * 
 * @export
 */
export type TableUpdate = any
/**
 * 
 * @export
 */
export type Term = any
/**
 * Time type values follow the 'HH:MM:SS.ssssss' ISO-8601 format with microsecond precision
 * @export
 */
export type TimeTypeValue = any
/**
 * 
 * @export
 * @interface TimerResult
 */
export interface TimerResult {
    /**
     * 
     * @type {any}
     * @memberof TimerResult
     */
    timeUnit: any;
    /**
     * 
     * @type {any}
     * @memberof TimerResult
     */
    count: any;
    /**
     * 
     * @type {any}
     * @memberof TimerResult
     */
    totalDuration: any;
}
/**
 * Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss' ISO-8601 format with nanosecond precision
 * @export
 */
export type TimestampNanoTypeValue = any
/**
 * Timestamp type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss' ISO-8601 format with microsecond precision
 * @export
 */
export type TimestampTypeValue = any
/**
 * Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss+00:00' ISO-8601 format with nanosecond precision, and a timezone offset (+00:00 for UTC)
 * @export
 */
export type TimestampTzNanoTypeValue = any
/**
 * TimestampTz type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss+00:00' ISO-8601 format with microsecond precision, and a timezone offset (+00:00 for UTC)
 * @export
 */
export type TimestampTzTypeValue = any
/**
 * Token type identifier, from RFC 8693 Section 3  See https://datatracker.ietf.org/doc/html/rfc8693#section-3
 * @export
 * @enum {string}
 */
export enum TokenType {
    AccessToken = <any> 'urn:ietf:params:oauth:token-type:access_token',
    RefreshToken = <any> 'urn:ietf:params:oauth:token-type:refresh_token',
    IdToken = <any> 'urn:ietf:params:oauth:token-type:id_token',
    Saml1 = <any> 'urn:ietf:params:oauth:token-type:saml1',
    Saml2 = <any> 'urn:ietf:params:oauth:token-type:saml2',
    Jwt = <any> 'urn:ietf:params:oauth:token-type:jwt'
}
/**
 * 
 * @export
 */
export type Transform = any
/**
 * 
 * @export
 * @interface TransformTerm
 */
export interface TransformTerm {
    /**
     * 
     * @type {any}
     * @memberof TransformTerm
     */
    type: any;
    /**
     * 
     * @type {Transform}
     * @memberof TransformTerm
     */
    transform: Transform;
    /**
     * 
     * @type {Reference}
     * @memberof TransformTerm
     */
    term: Reference;
}
/**
 * 
 * @export
 * @interface TrueExpression
 */
export interface TrueExpression {
    /**
     * 
     * @type {ExpressionType}
     * @memberof TrueExpression
     */
    type: ExpressionType;
}
/**
 * 
 * @export
 */
export type Type = any
/**
 * UUID type values are serialized as a 36-character lowercase string in standard UUID format as specified by RFC-4122
 * @export
 */
export type UUIDTypeValue = any
/**
 * 
 * @export
 * @interface UnaryExpression
 */
export interface UnaryExpression {
    /**
     * 
     * @type {ExpressionType}
     * @memberof UnaryExpression
     */
    type: ExpressionType;
    /**
     * 
     * @type {Term}
     * @memberof UnaryExpression
     */
    term: Term;
    /**
     * 
     * @type {any}
     * @memberof UnaryExpression
     */
    value: any;
}
/**
 * 
 * @export
 * @interface UpdateNamespacePropertiesRequest
 */
export interface UpdateNamespacePropertiesRequest {
    /**
     * 
     * @type {any}
     * @memberof UpdateNamespacePropertiesRequest
     */
    removals?: any;
    /**
     * 
     * @type {any}
     * @memberof UpdateNamespacePropertiesRequest
     */
    updates?: any;
}
/**
 * 
 * @export
 * @interface UpdateNamespacePropertiesResponse
 */
export interface UpdateNamespacePropertiesResponse {
    /**
     * List of property keys that were added or updated
     * @type {any}
     * @memberof UpdateNamespacePropertiesResponse
     */
    updated: any;
    /**
     * List of properties that were removed
     * @type {any}
     * @memberof UpdateNamespacePropertiesResponse
     */
    removed: any;
    /**
     * List of properties requested for removal that were not found in the namespace's properties. Represents a partial success response. Server's do not need to implement this.
     * @type {any}
     * @memberof UpdateNamespacePropertiesResponse
     */
    missing?: any;
}
/**
 * 
 * @export
 * @interface UpgradeFormatVersionUpdate
 */
export interface UpgradeFormatVersionUpdate {
    /**
     * 
     * @type {any}
     * @memberof UpgradeFormatVersionUpdate
     */
    action?: any;
    /**
     * 
     * @type {any}
     * @memberof UpgradeFormatVersionUpdate
     */
    formatVersion: any;
}
/**
 * 
 * @export
 * @interface ValueMap
 */
export interface ValueMap {
    /**
     * List of integer column ids for each corresponding value
     * @type {any}
     * @memberof ValueMap
     */
    keys?: any;
    /**
     * List of primitive type values, matched to 'keys' by index
     * @type {any}
     * @memberof ValueMap
     */
    values?: any;
}
/**
 * 
 * @export
 * @interface ViewHistoryEntry
 */
export interface ViewHistoryEntry {
    /**
     * 
     * @type {any}
     * @memberof ViewHistoryEntry
     */
    versionId: any;
    /**
     * 
     * @type {any}
     * @memberof ViewHistoryEntry
     */
    timestampMs: any;
}
/**
 * 
 * @export
 * @interface ViewMetadata
 */
export interface ViewMetadata {
    /**
     * 
     * @type {any}
     * @memberof ViewMetadata
     */
    viewUuid: any;
    /**
     * 
     * @type {any}
     * @memberof ViewMetadata
     */
    formatVersion: any;
    /**
     * 
     * @type {any}
     * @memberof ViewMetadata
     */
    location: any;
    /**
     * 
     * @type {any}
     * @memberof ViewMetadata
     */
    currentVersionId: any;
    /**
     * 
     * @type {any}
     * @memberof ViewMetadata
     */
    versions: any;
    /**
     * 
     * @type {any}
     * @memberof ViewMetadata
     */
    versionLog: any;
    /**
     * 
     * @type {any}
     * @memberof ViewMetadata
     */
    schemas: any;
    /**
     * 
     * @type {any}
     * @memberof ViewMetadata
     */
    properties?: any;
}
/**
 * 
 * @export
 */
export type ViewRepresentation = any
/**
 * 
 * @export
 */
export type ViewRequirement = any
/**
 * 
 * @export
 */
export type ViewUpdate = any
/**
 * 
 * @export
 * @interface ViewVersion
 */
export interface ViewVersion {
    /**
     * 
     * @type {any}
     * @memberof ViewVersion
     */
    versionId: any;
    /**
     * 
     * @type {any}
     * @memberof ViewVersion
     */
    timestampMs: any;
    /**
     * Schema ID to set as current, or -1 to set last added schema
     * @type {any}
     * @memberof ViewVersion
     */
    schemaId: any;
    /**
     * 
     * @type {any}
     * @memberof ViewVersion
     */
    summary: any;
    /**
     * 
     * @type {any}
     * @memberof ViewVersion
     */
    representations: any;
    /**
     * 
     * @type {any}
     * @memberof ViewVersion
     */
    defaultCatalog?: any;
    /**
     * 
     * @type {Namespace}
     * @memberof ViewVersion
     */
    defaultNamespace: Namespace;
}
/**
 * CatalogAPIApi - fetch parameter creator
 * @export
 */
export const CatalogAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels scan planning for a plan-id.  This notifies the service that it can release resources held for the scan. Clients should cancel scans that are no longer needed, either while the plan-id returns a \"submitted\" status or while there are remaining plan tasks that have not been fetched.  Cancellation is not necessary when - Scan tasks for each plan task have been fetched using fetchScanTasks - A plan-id has produced a \"failed\" or \"cancelled\" status from   planTableScan or fetchPlanningResult 
         * @summary Cancels scan planning for a plan-id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPlanning(options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables/{table}/plan/{plan-id}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Commit updates to multiple tables in an atomic operation
         * @param {CommitTransactionRequest} body Commit updates to multiple tables in an atomic operation  A commit for a single table consists of a table identifier with requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, &#x60;assert-ref-snapshot-id&#x60; will check that a named ref&#x27;s snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received. Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitTransaction(body: CommitTransactionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling commitTransaction.');
            }
            const localVarPath = `/v1/{prefix}/transactions/commit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CommitTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a namespace, with an optional set of properties. The server might also add properties, such as `last_modified_time` etc.
         * @summary Create a namespace
         * @param {CreateNamespaceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(body: CreateNamespaceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createNamespace.');
            }
            const localVarPath = `/v1/{prefix}/namespaces`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateNamespaceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a table or start a create transaction, like atomic CTAS.  If `stage-create` is false, the table is created immediately.  If `stage-create` is true, the table is not created, but table metadata is initialized and returned. The service should prepare as needed for a commit to the table commit endpoint to complete the create transaction. The client uses the returned metadata to begin a transaction. To commit the transaction, the client sends all create and subsequent changes to the table commit route. Changes from the table create operation include changes like AddSchemaUpdate and SetCurrentSchemaUpdate that set the initial table state.
         * @summary Create a table in the given namespace
         * @param {CreateTableRequest} body 
         * @param {any} [xIcebergAccessDelegation] Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.  Specific properties and handling for &#x60;vended-credentials&#x60; is documented in the &#x60;LoadTableResult&#x60; schema section of this spec document.  The protocol and specification for &#x60;remote-signing&#x60; is documented in  the &#x60;s3-signer-open-api.yaml&#x60; OpenApi spec in the &#x60;aws&#x60; module. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTable(body: CreateTableRequest, xIcebergAccessDelegation?: any, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTable.');
            }
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (xIcebergAccessDelegation !== undefined && xIcebergAccessDelegation !== null) {
                localVarHeaderParameter['X-Iceberg-Access-Delegation'] = String(xIcebergAccessDelegation);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateTableRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a view in the given namespace.
         * @summary Create a view in the given namespace
         * @param {CreateViewRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createView(body: CreateViewRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createView.');
            }
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/views`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateViewRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Drop a namespace from the catalog. Namespace must be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropNamespace(options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a table from the catalog
         * @summary Drop a table from the catalog
         * @param {any} prefix An optional prefix in the path
         * @param {any} namespace A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (&#x60;0x1F&#x60;) byte.
         * @param {any} table A table name
         * @param {any} [purgeRequested] Whether the user requested to purge the underlying table&#x27;s data and metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropTable(prefix: any, namespace: any, table: any, purgeRequested?: any, options: any = {}): FetchArgs {
            // verify required parameter 'prefix' is not null or undefined
            if (prefix === null || prefix === undefined) {
                throw new RequiredError('prefix','Required parameter prefix was null or undefined when calling dropTable.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling dropTable.');
            }
            // verify required parameter 'table' is not null or undefined
            if (table === null || table === undefined) {
                throw new RequiredError('table','Required parameter table was null or undefined when calling dropTable.');
            }
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables/{table}`
                .replace(`{${"prefix"}}`, encodeURIComponent(String(prefix)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"table"}}`, encodeURIComponent(String(table)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (purgeRequested !== undefined) {
                localVarQueryParameter['purgeRequested'] = purgeRequested;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a view from the catalog
         * @summary Drop a view from the catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropView(options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/views/{view}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the result of scan planning for a plan-id.  Responses must include a valid status - When \"completed\" the planning operation has produced plan-tasks and   file-scan-tasks that must be returned in the response  - When \"submitted\" the planning operation has not completed; the client   should wait to call this endpoint again to fetch a completed response  - When \"failed\" the response must be a valid error response - When \"cancelled\" the plan-id is invalid and should be discarded  The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status. 
         * @summary Fetches the result of scan planning for a plan-id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPlanningResult(options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables/{table}/plan/{plan-id}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches result tasks for a plan task.
         * @summary Fetches result tasks for a plan task
         * @param {FetchScanTasksRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchScanTasks(body?: FetchScanTasksRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables/{table}/tasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FetchScanTasksRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all namespaces at a certain level, optionally starting from a given parent namespace. If table accounting.tax.paid.info exists, using 'SELECT NAMESPACE IN accounting' would translate into `GET /namespaces?parent=accounting` and must return a namespace, [\"accounting\", \"tax\"] only. Using 'SELECT NAMESPACE IN accounting.tax' would translate into `GET /namespaces?parent=accounting%1Ftax` and must return a namespace, [\"accounting\", \"tax\", \"paid\"]. If `parent` is not provided, all top-level namespaces should be listed.
         * @summary List namespaces, optionally providing a parent namespace to list underneath
         * @param {PageToken} [pageToken] 
         * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
         * @param {any} [parent] An optional namespace, underneath which to list namespaces. If not provided or empty, all top-level namespaces should be listed. If parent is a multipart namespace, the parts must be separated by the unit separator (&#x60;0x1F&#x60;) byte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces(pageToken?: PageToken, pageSize?: any, parent?: any, options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all table identifiers under this namespace
         * @summary List all table identifiers underneath a given namespace
         * @param {PageToken} [pageToken] 
         * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTables(pageToken?: PageToken, pageSize?: any, options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all view identifiers under this namespace
         * @summary List all view identifiers underneath a given namespace
         * @param {PageToken} [pageToken] 
         * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews(pageToken?: PageToken, pageSize?: any, options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/views`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load vended credentials for a table from the catalog.
         * @summary Load vended credentials for a table from the catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadCredentials(options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables/{table}/credentials`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all stored metadata properties for a given namespace
         * @summary Load the metadata properties for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadNamespaceMetadata(options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load a table from the catalog.  The response contains both configuration and table metadata. The configuration, if non-empty is used as additional configuration for the table that overrides catalog configuration. For example, this configuration may change the FileIO implementation to be used for the table.  The response also contains the table's full metadata, matching the table metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the table. The configuration key \"token\" is used to pass an access token to be used as a bearer token for table requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
         * @summary Load a table from the catalog
         * @param {any} [xIcebergAccessDelegation] Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.  Specific properties and handling for &#x60;vended-credentials&#x60; is documented in the &#x60;LoadTableResult&#x60; schema section of this spec document.  The protocol and specification for &#x60;remote-signing&#x60; is documented in  the &#x60;s3-signer-open-api.yaml&#x60; OpenApi spec in the &#x60;aws&#x60; module. 
         * @param {any} [ifNoneMatch] An optional header that allows the server to return 304 (Not Modified) if the metadata is current. The content is the value of the ETag received in a CreateTableResponse or LoadTableResponse.
         * @param {any} [snapshots] The snapshots to return in the body of the metadata. Setting the value to &#x60;all&#x60; would return the full set of snapshots currently valid for the table. Setting the value to &#x60;refs&#x60; would load all snapshots referenced by branches or tags. Default if no param is provided is &#x60;all&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadTable(xIcebergAccessDelegation?: any, ifNoneMatch?: any, snapshots?: any, options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables/{table}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (snapshots !== undefined) {
                localVarQueryParameter['snapshots'] = snapshots;
            }

            if (xIcebergAccessDelegation !== undefined && xIcebergAccessDelegation !== null) {
                localVarHeaderParameter['X-Iceberg-Access-Delegation'] = String(xIcebergAccessDelegation);
            }

            if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
                localVarHeaderParameter['If-None-Match'] = String(ifNoneMatch);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load a view from the catalog.  The response contains both configuration and view metadata. The configuration, if non-empty is used as additional configuration for the view that overrides catalog configuration.  The response also contains the view's full metadata, matching the view metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the view. The configuration key \"token\" is used to pass an access token to be used as a bearer token for view requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
         * @summary Load a view from the catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadView(options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/views/{view}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a namespace exists. The response does not contain a body.
         * @summary Check if a namespace exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceExists(options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a scan for server-side planning.  Point-in-time scans are planned by passing snapshot-id to identify the table snapshot to scan. Incremental scans are planned by passing both start-snapshot-id and end-snapshot-id. Requests that include both point in time config properties and incremental config properties are invalid. If the request does not include either incremental or point-in-time config properties, scan planning should produce a point-in-time scan of the latest snapshot in the table's main branch.  Responses must include a valid status listed below. A \"cancelled\" status is considered invalid for this endpoint.   - When \"completed\" the planning operation has produced plan tasks and   file scan tasks that must be returned in the response (not fetched   later by calling fetchPlanningResult)  - When \"submitted\" the response must include a plan-id used to poll   fetchPlanningResult to fetch the planning result when it is ready  - When \"failed\" the response must be a valid error response The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status.  Responses that include a plan-id indicate that the service is holding state or performing work for the client.  - Clients should use the plan-id to fetch results from   fetchPlanningResult when the response status is \"submitted\"  - Clients should inform the service if planning results are no longer   needed by calling cancelPlanning. Cancellation is not necessary after   fetchScanTasks has been used to fetch scan tasks for each plan task. 
         * @summary Submit a scan for planning
         * @param {PlanTableScanRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planTableScan(body?: PlanTableScanRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables/{table}/plan`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PlanTableScanRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a table using given metadata file location.
         * @summary Register a table in the given namespace using given metadata file location
         * @param {RegisterTableRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerTable(body: RegisterTableRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling registerTable.');
            }
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegisterTableRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename a table from one identifier to another. It's valid to move a table across namespaces, but the server implementation is not required to support it.
         * @summary Rename a table from its current name to a new name
         * @param {RenameTableRequest} body Current table identifier to rename and new table identifier to rename to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTable(body: RenameTableRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling renameTable.');
            }
            const localVarPath = `/v1/{prefix}/tables/rename`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RenameTableRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rename a view from one identifier to another. It's valid to move a view across namespaces, but the server implementation is not required to support it.
         * @summary Rename a view from its current name to a new name
         * @param {RenameTableRequest} body Current view identifier to rename and new view identifier to rename to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameView(body: RenameTableRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling renameView.');
            }
            const localVarPath = `/v1/{prefix}/views/rename`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RenameTableRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Commit updates to a view.
         * @summary Replace a view
         * @param {CommitViewRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceView(body: CommitViewRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling replaceView.');
            }
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/views/{view}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CommitViewRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a metrics report to this endpoint to be processed by the backend
         * @param {ReportMetricsRequest} body The request containing the metrics report to be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportMetrics(body: ReportMetricsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reportMetrics.');
            }
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables/{table}/metrics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReportMetricsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a table exists within a given namespace. The response does not contain a body.
         * @summary Check if a table exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tableExists(options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables/{table}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set and/or remove properties on a namespace. The request body specifies a list of properties to remove and a map of key value pairs to update. Properties that are not in the request are not modified or removed by this call. Server implementations are not required to support namespace properties.
         * @summary Set or remove properties on a namespace
         * @param {UpdateNamespacePropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperties(body: UpdateNamespacePropertiesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProperties.');
            }
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/properties`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateNamespacePropertiesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Commit updates to a table.  Commits have two parts, requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, `assert-ref-snapshot-id` will check that a named ref's snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received.  Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.  Create table transactions that are started by createTable with `stage-create` set to true are committed using this route. Transactions should include all changes to the table, including table initialization, like AddSchemaUpdate and SetCurrentSchemaUpdate. The `assert-create` requirement is used to ensure that the table was not created concurrently.
         * @summary Commit updates to a table
         * @param {CommitTableRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTable(body: CommitTableRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTable.');
            }
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/tables/{table}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CommitTableRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a view exists within a given namespace. This request does not return a response body.
         * @summary Check if a view exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewExists(options: any = {}): FetchArgs {
            const localVarPath = `/v1/{prefix}/namespaces/{namespace}/views/{view}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogAPIApi - functional programming interface
 * @export
 */
export const CatalogAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Cancels scan planning for a plan-id.  This notifies the service that it can release resources held for the scan. Clients should cancel scans that are no longer needed, either while the plan-id returns a \"submitted\" status or while there are remaining plan tasks that have not been fetched.  Cancellation is not necessary when - Scan tasks for each plan task have been fetched using fetchScanTasks - A plan-id has produced a \"failed\" or \"cancelled\" status from   planTableScan or fetchPlanningResult 
         * @summary Cancels scan planning for a plan-id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPlanning(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).cancelPlanning(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Commit updates to multiple tables in an atomic operation
         * @param {CommitTransactionRequest} body Commit updates to multiple tables in an atomic operation  A commit for a single table consists of a table identifier with requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, &#x60;assert-ref-snapshot-id&#x60; will check that a named ref&#x27;s snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received. Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitTransaction(body: CommitTransactionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).commitTransaction(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a namespace, with an optional set of properties. The server might also add properties, such as `last_modified_time` etc.
         * @summary Create a namespace
         * @param {CreateNamespaceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(body: CreateNamespaceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).createNamespace(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a table or start a create transaction, like atomic CTAS.  If `stage-create` is false, the table is created immediately.  If `stage-create` is true, the table is not created, but table metadata is initialized and returned. The service should prepare as needed for a commit to the table commit endpoint to complete the create transaction. The client uses the returned metadata to begin a transaction. To commit the transaction, the client sends all create and subsequent changes to the table commit route. Changes from the table create operation include changes like AddSchemaUpdate and SetCurrentSchemaUpdate that set the initial table state.
         * @summary Create a table in the given namespace
         * @param {CreateTableRequest} body 
         * @param {any} [xIcebergAccessDelegation] Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.  Specific properties and handling for &#x60;vended-credentials&#x60; is documented in the &#x60;LoadTableResult&#x60; schema section of this spec document.  The protocol and specification for &#x60;remote-signing&#x60; is documented in  the &#x60;s3-signer-open-api.yaml&#x60; OpenApi spec in the &#x60;aws&#x60; module. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTable(body: CreateTableRequest, xIcebergAccessDelegation?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).createTable(body, xIcebergAccessDelegation, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a view in the given namespace.
         * @summary Create a view in the given namespace
         * @param {CreateViewRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createView(body: CreateViewRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).createView(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Drop a namespace from the catalog. Namespace must be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropNamespace(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).dropNamespace(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a table from the catalog
         * @summary Drop a table from the catalog
         * @param {any} prefix An optional prefix in the path
         * @param {any} namespace A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (&#x60;0x1F&#x60;) byte.
         * @param {any} table A table name
         * @param {any} [purgeRequested] Whether the user requested to purge the underlying table&#x27;s data and metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropTable(prefix: any, namespace: any, table: any, purgeRequested?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).dropTable(prefix, namespace, table, purgeRequested, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a view from the catalog
         * @summary Drop a view from the catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropView(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).dropView(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches the result of scan planning for a plan-id.  Responses must include a valid status - When \"completed\" the planning operation has produced plan-tasks and   file-scan-tasks that must be returned in the response  - When \"submitted\" the planning operation has not completed; the client   should wait to call this endpoint again to fetch a completed response  - When \"failed\" the response must be a valid error response - When \"cancelled\" the plan-id is invalid and should be discarded  The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status. 
         * @summary Fetches the result of scan planning for a plan-id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPlanningResult(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).fetchPlanningResult(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches result tasks for a plan task.
         * @summary Fetches result tasks for a plan task
         * @param {FetchScanTasksRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchScanTasks(body?: FetchScanTasksRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).fetchScanTasks(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all namespaces at a certain level, optionally starting from a given parent namespace. If table accounting.tax.paid.info exists, using 'SELECT NAMESPACE IN accounting' would translate into `GET /namespaces?parent=accounting` and must return a namespace, [\"accounting\", \"tax\"] only. Using 'SELECT NAMESPACE IN accounting.tax' would translate into `GET /namespaces?parent=accounting%1Ftax` and must return a namespace, [\"accounting\", \"tax\", \"paid\"]. If `parent` is not provided, all top-level namespaces should be listed.
         * @summary List namespaces, optionally providing a parent namespace to list underneath
         * @param {PageToken} [pageToken] 
         * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
         * @param {any} [parent] An optional namespace, underneath which to list namespaces. If not provided or empty, all top-level namespaces should be listed. If parent is a multipart namespace, the parts must be separated by the unit separator (&#x60;0x1F&#x60;) byte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces(pageToken?: PageToken, pageSize?: any, parent?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).listNamespaces(pageToken, pageSize, parent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return all table identifiers under this namespace
         * @summary List all table identifiers underneath a given namespace
         * @param {PageToken} [pageToken] 
         * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTables(pageToken?: PageToken, pageSize?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).listTables(pageToken, pageSize, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return all view identifiers under this namespace
         * @summary List all view identifiers underneath a given namespace
         * @param {PageToken} [pageToken] 
         * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews(pageToken?: PageToken, pageSize?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).listViews(pageToken, pageSize, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Load vended credentials for a table from the catalog.
         * @summary Load vended credentials for a table from the catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadCredentials(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).loadCredentials(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return all stored metadata properties for a given namespace
         * @summary Load the metadata properties for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadNamespaceMetadata(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).loadNamespaceMetadata(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Load a table from the catalog.  The response contains both configuration and table metadata. The configuration, if non-empty is used as additional configuration for the table that overrides catalog configuration. For example, this configuration may change the FileIO implementation to be used for the table.  The response also contains the table's full metadata, matching the table metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the table. The configuration key \"token\" is used to pass an access token to be used as a bearer token for table requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
         * @summary Load a table from the catalog
         * @param {any} [xIcebergAccessDelegation] Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.  Specific properties and handling for &#x60;vended-credentials&#x60; is documented in the &#x60;LoadTableResult&#x60; schema section of this spec document.  The protocol and specification for &#x60;remote-signing&#x60; is documented in  the &#x60;s3-signer-open-api.yaml&#x60; OpenApi spec in the &#x60;aws&#x60; module. 
         * @param {any} [ifNoneMatch] An optional header that allows the server to return 304 (Not Modified) if the metadata is current. The content is the value of the ETag received in a CreateTableResponse or LoadTableResponse.
         * @param {any} [snapshots] The snapshots to return in the body of the metadata. Setting the value to &#x60;all&#x60; would return the full set of snapshots currently valid for the table. Setting the value to &#x60;refs&#x60; would load all snapshots referenced by branches or tags. Default if no param is provided is &#x60;all&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadTable(xIcebergAccessDelegation?: any, ifNoneMatch?: any, snapshots?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).loadTable(xIcebergAccessDelegation, ifNoneMatch, snapshots, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Load a view from the catalog.  The response contains both configuration and view metadata. The configuration, if non-empty is used as additional configuration for the view that overrides catalog configuration.  The response also contains the view's full metadata, matching the view metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the view. The configuration key \"token\" is used to pass an access token to be used as a bearer token for view requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
         * @summary Load a view from the catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadView(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).loadView(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if a namespace exists. The response does not contain a body.
         * @summary Check if a namespace exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceExists(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).namespaceExists(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Submits a scan for server-side planning.  Point-in-time scans are planned by passing snapshot-id to identify the table snapshot to scan. Incremental scans are planned by passing both start-snapshot-id and end-snapshot-id. Requests that include both point in time config properties and incremental config properties are invalid. If the request does not include either incremental or point-in-time config properties, scan planning should produce a point-in-time scan of the latest snapshot in the table's main branch.  Responses must include a valid status listed below. A \"cancelled\" status is considered invalid for this endpoint.   - When \"completed\" the planning operation has produced plan tasks and   file scan tasks that must be returned in the response (not fetched   later by calling fetchPlanningResult)  - When \"submitted\" the response must include a plan-id used to poll   fetchPlanningResult to fetch the planning result when it is ready  - When \"failed\" the response must be a valid error response The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status.  Responses that include a plan-id indicate that the service is holding state or performing work for the client.  - Clients should use the plan-id to fetch results from   fetchPlanningResult when the response status is \"submitted\"  - Clients should inform the service if planning results are no longer   needed by calling cancelPlanning. Cancellation is not necessary after   fetchScanTasks has been used to fetch scan tasks for each plan task. 
         * @summary Submit a scan for planning
         * @param {PlanTableScanRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planTableScan(body?: PlanTableScanRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).planTableScan(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Register a table using given metadata file location.
         * @summary Register a table in the given namespace using given metadata file location
         * @param {RegisterTableRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerTable(body: RegisterTableRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).registerTable(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Rename a table from one identifier to another. It's valid to move a table across namespaces, but the server implementation is not required to support it.
         * @summary Rename a table from its current name to a new name
         * @param {RenameTableRequest} body Current table identifier to rename and new table identifier to rename to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTable(body: RenameTableRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).renameTable(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Rename a view from one identifier to another. It's valid to move a view across namespaces, but the server implementation is not required to support it.
         * @summary Rename a view from its current name to a new name
         * @param {RenameTableRequest} body Current view identifier to rename and new view identifier to rename to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameView(body: RenameTableRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).renameView(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Commit updates to a view.
         * @summary Replace a view
         * @param {CommitViewRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceView(body: CommitViewRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).replaceView(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send a metrics report to this endpoint to be processed by the backend
         * @param {ReportMetricsRequest} body The request containing the metrics report to be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportMetrics(body: ReportMetricsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).reportMetrics(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if a table exists within a given namespace. The response does not contain a body.
         * @summary Check if a table exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tableExists(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).tableExists(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set and/or remove properties on a namespace. The request body specifies a list of properties to remove and a map of key value pairs to update. Properties that are not in the request are not modified or removed by this call. Server implementations are not required to support namespace properties.
         * @summary Set or remove properties on a namespace
         * @param {UpdateNamespacePropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperties(body: UpdateNamespacePropertiesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).updateProperties(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Commit updates to a table.  Commits have two parts, requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, `assert-ref-snapshot-id` will check that a named ref's snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received.  Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.  Create table transactions that are started by createTable with `stage-create` set to true are committed using this route. Transactions should include all changes to the table, including table initialization, like AddSchemaUpdate and SetCurrentSchemaUpdate. The `assert-create` requirement is used to ensure that the table was not created concurrently.
         * @summary Commit updates to a table
         * @param {CommitTableRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTable(body: CommitTableRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).updateTable(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if a view exists within a given namespace. This request does not return a response body.
         * @summary Check if a view exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewExists(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CatalogAPIApiFetchParamCreator(configuration).viewExists(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogAPIApi - factory interface
 * @export
 */
export const CatalogAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Cancels scan planning for a plan-id.  This notifies the service that it can release resources held for the scan. Clients should cancel scans that are no longer needed, either while the plan-id returns a \"submitted\" status or while there are remaining plan tasks that have not been fetched.  Cancellation is not necessary when - Scan tasks for each plan task have been fetched using fetchScanTasks - A plan-id has produced a \"failed\" or \"cancelled\" status from   planTableScan or fetchPlanningResult 
         * @summary Cancels scan planning for a plan-id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPlanning(options?: any) {
            return CatalogAPIApiFp(configuration).cancelPlanning(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Commit updates to multiple tables in an atomic operation
         * @param {CommitTransactionRequest} body Commit updates to multiple tables in an atomic operation  A commit for a single table consists of a table identifier with requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, &#x60;assert-ref-snapshot-id&#x60; will check that a named ref&#x27;s snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received. Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitTransaction(body: CommitTransactionRequest, options?: any) {
            return CatalogAPIApiFp(configuration).commitTransaction(body, options)(fetch, basePath);
        },
        /**
         * Create a namespace, with an optional set of properties. The server might also add properties, such as `last_modified_time` etc.
         * @summary Create a namespace
         * @param {CreateNamespaceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(body: CreateNamespaceRequest, options?: any) {
            return CatalogAPIApiFp(configuration).createNamespace(body, options)(fetch, basePath);
        },
        /**
         * Create a table or start a create transaction, like atomic CTAS.  If `stage-create` is false, the table is created immediately.  If `stage-create` is true, the table is not created, but table metadata is initialized and returned. The service should prepare as needed for a commit to the table commit endpoint to complete the create transaction. The client uses the returned metadata to begin a transaction. To commit the transaction, the client sends all create and subsequent changes to the table commit route. Changes from the table create operation include changes like AddSchemaUpdate and SetCurrentSchemaUpdate that set the initial table state.
         * @summary Create a table in the given namespace
         * @param {CreateTableRequest} body 
         * @param {any} [xIcebergAccessDelegation] Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.  Specific properties and handling for &#x60;vended-credentials&#x60; is documented in the &#x60;LoadTableResult&#x60; schema section of this spec document.  The protocol and specification for &#x60;remote-signing&#x60; is documented in  the &#x60;s3-signer-open-api.yaml&#x60; OpenApi spec in the &#x60;aws&#x60; module. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTable(body: CreateTableRequest, xIcebergAccessDelegation?: any, options?: any) {
            return CatalogAPIApiFp(configuration).createTable(body, xIcebergAccessDelegation, options)(fetch, basePath);
        },
        /**
         * Create a view in the given namespace.
         * @summary Create a view in the given namespace
         * @param {CreateViewRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createView(body: CreateViewRequest, options?: any) {
            return CatalogAPIApiFp(configuration).createView(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Drop a namespace from the catalog. Namespace must be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropNamespace(options?: any) {
            return CatalogAPIApiFp(configuration).dropNamespace(options)(fetch, basePath);
        },
        /**
         * Remove a table from the catalog
         * @summary Drop a table from the catalog
         * @param {any} prefix An optional prefix in the path
         * @param {any} namespace A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (&#x60;0x1F&#x60;) byte.
         * @param {any} table A table name
         * @param {any} [purgeRequested] Whether the user requested to purge the underlying table&#x27;s data and metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropTable(prefix: any, namespace: any, table: any, purgeRequested?: any, options?: any) {
            return CatalogAPIApiFp(configuration).dropTable(prefix, namespace, table, purgeRequested, options)(fetch, basePath);
        },
        /**
         * Remove a view from the catalog
         * @summary Drop a view from the catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dropView(options?: any) {
            return CatalogAPIApiFp(configuration).dropView(options)(fetch, basePath);
        },
        /**
         * Fetches the result of scan planning for a plan-id.  Responses must include a valid status - When \"completed\" the planning operation has produced plan-tasks and   file-scan-tasks that must be returned in the response  - When \"submitted\" the planning operation has not completed; the client   should wait to call this endpoint again to fetch a completed response  - When \"failed\" the response must be a valid error response - When \"cancelled\" the plan-id is invalid and should be discarded  The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status. 
         * @summary Fetches the result of scan planning for a plan-id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPlanningResult(options?: any) {
            return CatalogAPIApiFp(configuration).fetchPlanningResult(options)(fetch, basePath);
        },
        /**
         * Fetches result tasks for a plan task.
         * @summary Fetches result tasks for a plan task
         * @param {FetchScanTasksRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchScanTasks(body?: FetchScanTasksRequest, options?: any) {
            return CatalogAPIApiFp(configuration).fetchScanTasks(body, options)(fetch, basePath);
        },
        /**
         * List all namespaces at a certain level, optionally starting from a given parent namespace. If table accounting.tax.paid.info exists, using 'SELECT NAMESPACE IN accounting' would translate into `GET /namespaces?parent=accounting` and must return a namespace, [\"accounting\", \"tax\"] only. Using 'SELECT NAMESPACE IN accounting.tax' would translate into `GET /namespaces?parent=accounting%1Ftax` and must return a namespace, [\"accounting\", \"tax\", \"paid\"]. If `parent` is not provided, all top-level namespaces should be listed.
         * @summary List namespaces, optionally providing a parent namespace to list underneath
         * @param {PageToken} [pageToken] 
         * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
         * @param {any} [parent] An optional namespace, underneath which to list namespaces. If not provided or empty, all top-level namespaces should be listed. If parent is a multipart namespace, the parts must be separated by the unit separator (&#x60;0x1F&#x60;) byte.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNamespaces(pageToken?: PageToken, pageSize?: any, parent?: any, options?: any) {
            return CatalogAPIApiFp(configuration).listNamespaces(pageToken, pageSize, parent, options)(fetch, basePath);
        },
        /**
         * Return all table identifiers under this namespace
         * @summary List all table identifiers underneath a given namespace
         * @param {PageToken} [pageToken] 
         * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTables(pageToken?: PageToken, pageSize?: any, options?: any) {
            return CatalogAPIApiFp(configuration).listTables(pageToken, pageSize, options)(fetch, basePath);
        },
        /**
         * Return all view identifiers under this namespace
         * @summary List all view identifiers underneath a given namespace
         * @param {PageToken} [pageToken] 
         * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews(pageToken?: PageToken, pageSize?: any, options?: any) {
            return CatalogAPIApiFp(configuration).listViews(pageToken, pageSize, options)(fetch, basePath);
        },
        /**
         * Load vended credentials for a table from the catalog.
         * @summary Load vended credentials for a table from the catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadCredentials(options?: any) {
            return CatalogAPIApiFp(configuration).loadCredentials(options)(fetch, basePath);
        },
        /**
         * Return all stored metadata properties for a given namespace
         * @summary Load the metadata properties for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadNamespaceMetadata(options?: any) {
            return CatalogAPIApiFp(configuration).loadNamespaceMetadata(options)(fetch, basePath);
        },
        /**
         * Load a table from the catalog.  The response contains both configuration and table metadata. The configuration, if non-empty is used as additional configuration for the table that overrides catalog configuration. For example, this configuration may change the FileIO implementation to be used for the table.  The response also contains the table's full metadata, matching the table metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the table. The configuration key \"token\" is used to pass an access token to be used as a bearer token for table requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
         * @summary Load a table from the catalog
         * @param {any} [xIcebergAccessDelegation] Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.  Specific properties and handling for &#x60;vended-credentials&#x60; is documented in the &#x60;LoadTableResult&#x60; schema section of this spec document.  The protocol and specification for &#x60;remote-signing&#x60; is documented in  the &#x60;s3-signer-open-api.yaml&#x60; OpenApi spec in the &#x60;aws&#x60; module. 
         * @param {any} [ifNoneMatch] An optional header that allows the server to return 304 (Not Modified) if the metadata is current. The content is the value of the ETag received in a CreateTableResponse or LoadTableResponse.
         * @param {any} [snapshots] The snapshots to return in the body of the metadata. Setting the value to &#x60;all&#x60; would return the full set of snapshots currently valid for the table. Setting the value to &#x60;refs&#x60; would load all snapshots referenced by branches or tags. Default if no param is provided is &#x60;all&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadTable(xIcebergAccessDelegation?: any, ifNoneMatch?: any, snapshots?: any, options?: any) {
            return CatalogAPIApiFp(configuration).loadTable(xIcebergAccessDelegation, ifNoneMatch, snapshots, options)(fetch, basePath);
        },
        /**
         * Load a view from the catalog.  The response contains both configuration and view metadata. The configuration, if non-empty is used as additional configuration for the view that overrides catalog configuration.  The response also contains the view's full metadata, matching the view metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the view. The configuration key \"token\" is used to pass an access token to be used as a bearer token for view requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
         * @summary Load a view from the catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadView(options?: any) {
            return CatalogAPIApiFp(configuration).loadView(options)(fetch, basePath);
        },
        /**
         * Check if a namespace exists. The response does not contain a body.
         * @summary Check if a namespace exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceExists(options?: any) {
            return CatalogAPIApiFp(configuration).namespaceExists(options)(fetch, basePath);
        },
        /**
         * Submits a scan for server-side planning.  Point-in-time scans are planned by passing snapshot-id to identify the table snapshot to scan. Incremental scans are planned by passing both start-snapshot-id and end-snapshot-id. Requests that include both point in time config properties and incremental config properties are invalid. If the request does not include either incremental or point-in-time config properties, scan planning should produce a point-in-time scan of the latest snapshot in the table's main branch.  Responses must include a valid status listed below. A \"cancelled\" status is considered invalid for this endpoint.   - When \"completed\" the planning operation has produced plan tasks and   file scan tasks that must be returned in the response (not fetched   later by calling fetchPlanningResult)  - When \"submitted\" the response must include a plan-id used to poll   fetchPlanningResult to fetch the planning result when it is ready  - When \"failed\" the response must be a valid error response The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status.  Responses that include a plan-id indicate that the service is holding state or performing work for the client.  - Clients should use the plan-id to fetch results from   fetchPlanningResult when the response status is \"submitted\"  - Clients should inform the service if planning results are no longer   needed by calling cancelPlanning. Cancellation is not necessary after   fetchScanTasks has been used to fetch scan tasks for each plan task. 
         * @summary Submit a scan for planning
         * @param {PlanTableScanRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        planTableScan(body?: PlanTableScanRequest, options?: any) {
            return CatalogAPIApiFp(configuration).planTableScan(body, options)(fetch, basePath);
        },
        /**
         * Register a table using given metadata file location.
         * @summary Register a table in the given namespace using given metadata file location
         * @param {RegisterTableRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerTable(body: RegisterTableRequest, options?: any) {
            return CatalogAPIApiFp(configuration).registerTable(body, options)(fetch, basePath);
        },
        /**
         * Rename a table from one identifier to another. It's valid to move a table across namespaces, but the server implementation is not required to support it.
         * @summary Rename a table from its current name to a new name
         * @param {RenameTableRequest} body Current table identifier to rename and new table identifier to rename to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameTable(body: RenameTableRequest, options?: any) {
            return CatalogAPIApiFp(configuration).renameTable(body, options)(fetch, basePath);
        },
        /**
         * Rename a view from one identifier to another. It's valid to move a view across namespaces, but the server implementation is not required to support it.
         * @summary Rename a view from its current name to a new name
         * @param {RenameTableRequest} body Current view identifier to rename and new view identifier to rename to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameView(body: RenameTableRequest, options?: any) {
            return CatalogAPIApiFp(configuration).renameView(body, options)(fetch, basePath);
        },
        /**
         * Commit updates to a view.
         * @summary Replace a view
         * @param {CommitViewRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceView(body: CommitViewRequest, options?: any) {
            return CatalogAPIApiFp(configuration).replaceView(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send a metrics report to this endpoint to be processed by the backend
         * @param {ReportMetricsRequest} body The request containing the metrics report to be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportMetrics(body: ReportMetricsRequest, options?: any) {
            return CatalogAPIApiFp(configuration).reportMetrics(body, options)(fetch, basePath);
        },
        /**
         * Check if a table exists within a given namespace. The response does not contain a body.
         * @summary Check if a table exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tableExists(options?: any) {
            return CatalogAPIApiFp(configuration).tableExists(options)(fetch, basePath);
        },
        /**
         * Set and/or remove properties on a namespace. The request body specifies a list of properties to remove and a map of key value pairs to update. Properties that are not in the request are not modified or removed by this call. Server implementations are not required to support namespace properties.
         * @summary Set or remove properties on a namespace
         * @param {UpdateNamespacePropertiesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperties(body: UpdateNamespacePropertiesRequest, options?: any) {
            return CatalogAPIApiFp(configuration).updateProperties(body, options)(fetch, basePath);
        },
        /**
         * Commit updates to a table.  Commits have two parts, requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, `assert-ref-snapshot-id` will check that a named ref's snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received.  Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.  Create table transactions that are started by createTable with `stage-create` set to true are committed using this route. Transactions should include all changes to the table, including table initialization, like AddSchemaUpdate and SetCurrentSchemaUpdate. The `assert-create` requirement is used to ensure that the table was not created concurrently.
         * @summary Commit updates to a table
         * @param {CommitTableRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTable(body: CommitTableRequest, options?: any) {
            return CatalogAPIApiFp(configuration).updateTable(body, options)(fetch, basePath);
        },
        /**
         * Check if a view exists within a given namespace. This request does not return a response body.
         * @summary Check if a view exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewExists(options?: any) {
            return CatalogAPIApiFp(configuration).viewExists(options)(fetch, basePath);
        },
    };
};

/**
 * CatalogAPIApi - object-oriented interface
 * @export
 * @class CatalogAPIApi
 * @extends {BaseAPI}
 */
export class CatalogAPIApi extends BaseAPI {
    /**
     * Cancels scan planning for a plan-id.  This notifies the service that it can release resources held for the scan. Clients should cancel scans that are no longer needed, either while the plan-id returns a \"submitted\" status or while there are remaining plan tasks that have not been fetched.  Cancellation is not necessary when - Scan tasks for each plan task have been fetched using fetchScanTasks - A plan-id has produced a \"failed\" or \"cancelled\" status from   planTableScan or fetchPlanningResult 
     * @summary Cancels scan planning for a plan-id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public cancelPlanning(options?: any) {
        return CatalogAPIApiFp(this.configuration).cancelPlanning(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Commit updates to multiple tables in an atomic operation
     * @param {CommitTransactionRequest} body Commit updates to multiple tables in an atomic operation  A commit for a single table consists of a table identifier with requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, &#x60;assert-ref-snapshot-id&#x60; will check that a named ref&#x27;s snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received. Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public commitTransaction(body: CommitTransactionRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).commitTransaction(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a namespace, with an optional set of properties. The server might also add properties, such as `last_modified_time` etc.
     * @summary Create a namespace
     * @param {CreateNamespaceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public createNamespace(body: CreateNamespaceRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).createNamespace(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a table or start a create transaction, like atomic CTAS.  If `stage-create` is false, the table is created immediately.  If `stage-create` is true, the table is not created, but table metadata is initialized and returned. The service should prepare as needed for a commit to the table commit endpoint to complete the create transaction. The client uses the returned metadata to begin a transaction. To commit the transaction, the client sends all create and subsequent changes to the table commit route. Changes from the table create operation include changes like AddSchemaUpdate and SetCurrentSchemaUpdate that set the initial table state.
     * @summary Create a table in the given namespace
     * @param {CreateTableRequest} body 
     * @param {any} [xIcebergAccessDelegation] Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.  Specific properties and handling for &#x60;vended-credentials&#x60; is documented in the &#x60;LoadTableResult&#x60; schema section of this spec document.  The protocol and specification for &#x60;remote-signing&#x60; is documented in  the &#x60;s3-signer-open-api.yaml&#x60; OpenApi spec in the &#x60;aws&#x60; module. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public createTable(body: CreateTableRequest, xIcebergAccessDelegation?: any, options?: any) {
        return CatalogAPIApiFp(this.configuration).createTable(body, xIcebergAccessDelegation, options)(this.fetch, this.basePath);
    }

    /**
     * Create a view in the given namespace.
     * @summary Create a view in the given namespace
     * @param {CreateViewRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public createView(body: CreateViewRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).createView(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Drop a namespace from the catalog. Namespace must be empty.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public dropNamespace(options?: any) {
        return CatalogAPIApiFp(this.configuration).dropNamespace(options)(this.fetch, this.basePath);
    }

    /**
     * Remove a table from the catalog
     * @summary Drop a table from the catalog
     * @param {any} prefix An optional prefix in the path
     * @param {any} namespace A namespace identifier as a single string. Multipart namespace parts should be separated by the unit separator (&#x60;0x1F&#x60;) byte.
     * @param {any} table A table name
     * @param {any} [purgeRequested] Whether the user requested to purge the underlying table&#x27;s data and metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public dropTable(prefix: any, namespace: any, table: any, purgeRequested?: any, options?: any) {
        return CatalogAPIApiFp(this.configuration).dropTable(prefix, namespace, table, purgeRequested, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a view from the catalog
     * @summary Drop a view from the catalog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public dropView(options?: any) {
        return CatalogAPIApiFp(this.configuration).dropView(options)(this.fetch, this.basePath);
    }

    /**
     * Fetches the result of scan planning for a plan-id.  Responses must include a valid status - When \"completed\" the planning operation has produced plan-tasks and   file-scan-tasks that must be returned in the response  - When \"submitted\" the planning operation has not completed; the client   should wait to call this endpoint again to fetch a completed response  - When \"failed\" the response must be a valid error response - When \"cancelled\" the plan-id is invalid and should be discarded  The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status. 
     * @summary Fetches the result of scan planning for a plan-id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public fetchPlanningResult(options?: any) {
        return CatalogAPIApiFp(this.configuration).fetchPlanningResult(options)(this.fetch, this.basePath);
    }

    /**
     * Fetches result tasks for a plan task.
     * @summary Fetches result tasks for a plan task
     * @param {FetchScanTasksRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public fetchScanTasks(body?: FetchScanTasksRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).fetchScanTasks(body, options)(this.fetch, this.basePath);
    }

    /**
     * List all namespaces at a certain level, optionally starting from a given parent namespace. If table accounting.tax.paid.info exists, using 'SELECT NAMESPACE IN accounting' would translate into `GET /namespaces?parent=accounting` and must return a namespace, [\"accounting\", \"tax\"] only. Using 'SELECT NAMESPACE IN accounting.tax' would translate into `GET /namespaces?parent=accounting%1Ftax` and must return a namespace, [\"accounting\", \"tax\", \"paid\"]. If `parent` is not provided, all top-level namespaces should be listed.
     * @summary List namespaces, optionally providing a parent namespace to list underneath
     * @param {PageToken} [pageToken] 
     * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
     * @param {any} [parent] An optional namespace, underneath which to list namespaces. If not provided or empty, all top-level namespaces should be listed. If parent is a multipart namespace, the parts must be separated by the unit separator (&#x60;0x1F&#x60;) byte.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public listNamespaces(pageToken?: PageToken, pageSize?: any, parent?: any, options?: any) {
        return CatalogAPIApiFp(this.configuration).listNamespaces(pageToken, pageSize, parent, options)(this.fetch, this.basePath);
    }

    /**
     * Return all table identifiers under this namespace
     * @summary List all table identifiers underneath a given namespace
     * @param {PageToken} [pageToken] 
     * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public listTables(pageToken?: PageToken, pageSize?: any, options?: any) {
        return CatalogAPIApiFp(this.configuration).listTables(pageToken, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * Return all view identifiers under this namespace
     * @summary List all view identifiers underneath a given namespace
     * @param {PageToken} [pageToken] 
     * @param {any} [pageSize] For servers that support pagination, this signals an upper bound of the number of results that a client will receive. For servers that do not support pagination, clients may receive results larger than the indicated &#x60;pageSize&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public listViews(pageToken?: PageToken, pageSize?: any, options?: any) {
        return CatalogAPIApiFp(this.configuration).listViews(pageToken, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * Load vended credentials for a table from the catalog.
     * @summary Load vended credentials for a table from the catalog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public loadCredentials(options?: any) {
        return CatalogAPIApiFp(this.configuration).loadCredentials(options)(this.fetch, this.basePath);
    }

    /**
     * Return all stored metadata properties for a given namespace
     * @summary Load the metadata properties for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public loadNamespaceMetadata(options?: any) {
        return CatalogAPIApiFp(this.configuration).loadNamespaceMetadata(options)(this.fetch, this.basePath);
    }

    /**
     * Load a table from the catalog.  The response contains both configuration and table metadata. The configuration, if non-empty is used as additional configuration for the table that overrides catalog configuration. For example, this configuration may change the FileIO implementation to be used for the table.  The response also contains the table's full metadata, matching the table metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the table. The configuration key \"token\" is used to pass an access token to be used as a bearer token for table requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
     * @summary Load a table from the catalog
     * @param {any} [xIcebergAccessDelegation] Optional signal to the server that the client supports delegated access via a comma-separated list of access mechanisms.  The server may choose to supply access via any or none of the requested mechanisms.  Specific properties and handling for &#x60;vended-credentials&#x60; is documented in the &#x60;LoadTableResult&#x60; schema section of this spec document.  The protocol and specification for &#x60;remote-signing&#x60; is documented in  the &#x60;s3-signer-open-api.yaml&#x60; OpenApi spec in the &#x60;aws&#x60; module. 
     * @param {any} [ifNoneMatch] An optional header that allows the server to return 304 (Not Modified) if the metadata is current. The content is the value of the ETag received in a CreateTableResponse or LoadTableResponse.
     * @param {any} [snapshots] The snapshots to return in the body of the metadata. Setting the value to &#x60;all&#x60; would return the full set of snapshots currently valid for the table. Setting the value to &#x60;refs&#x60; would load all snapshots referenced by branches or tags. Default if no param is provided is &#x60;all&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public loadTable(xIcebergAccessDelegation?: any, ifNoneMatch?: any, snapshots?: any, options?: any) {
        return CatalogAPIApiFp(this.configuration).loadTable(xIcebergAccessDelegation, ifNoneMatch, snapshots, options)(this.fetch, this.basePath);
    }

    /**
     * Load a view from the catalog.  The response contains both configuration and view metadata. The configuration, if non-empty is used as additional configuration for the view that overrides catalog configuration.  The response also contains the view's full metadata, matching the view metadata JSON file.  The catalog configuration may contain credentials that should be used for subsequent requests for the view. The configuration key \"token\" is used to pass an access token to be used as a bearer token for view requests. Otherwise, a token may be passed using a RFC 8693 token type as a configuration key. For example, \"urn:ietf:params:oauth:token-type:jwt=<JWT-token>\".
     * @summary Load a view from the catalog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public loadView(options?: any) {
        return CatalogAPIApiFp(this.configuration).loadView(options)(this.fetch, this.basePath);
    }

    /**
     * Check if a namespace exists. The response does not contain a body.
     * @summary Check if a namespace exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public namespaceExists(options?: any) {
        return CatalogAPIApiFp(this.configuration).namespaceExists(options)(this.fetch, this.basePath);
    }

    /**
     * Submits a scan for server-side planning.  Point-in-time scans are planned by passing snapshot-id to identify the table snapshot to scan. Incremental scans are planned by passing both start-snapshot-id and end-snapshot-id. Requests that include both point in time config properties and incremental config properties are invalid. If the request does not include either incremental or point-in-time config properties, scan planning should produce a point-in-time scan of the latest snapshot in the table's main branch.  Responses must include a valid status listed below. A \"cancelled\" status is considered invalid for this endpoint.   - When \"completed\" the planning operation has produced plan tasks and   file scan tasks that must be returned in the response (not fetched   later by calling fetchPlanningResult)  - When \"submitted\" the response must include a plan-id used to poll   fetchPlanningResult to fetch the planning result when it is ready  - When \"failed\" the response must be a valid error response The response for a \"completed\" planning operation includes two types of tasks (file scan tasks and plan tasks) and both may be included in the response. Tasks must not be included for any other response status.  Responses that include a plan-id indicate that the service is holding state or performing work for the client.  - Clients should use the plan-id to fetch results from   fetchPlanningResult when the response status is \"submitted\"  - Clients should inform the service if planning results are no longer   needed by calling cancelPlanning. Cancellation is not necessary after   fetchScanTasks has been used to fetch scan tasks for each plan task. 
     * @summary Submit a scan for planning
     * @param {PlanTableScanRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public planTableScan(body?: PlanTableScanRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).planTableScan(body, options)(this.fetch, this.basePath);
    }

    /**
     * Register a table using given metadata file location.
     * @summary Register a table in the given namespace using given metadata file location
     * @param {RegisterTableRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public registerTable(body: RegisterTableRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).registerTable(body, options)(this.fetch, this.basePath);
    }

    /**
     * Rename a table from one identifier to another. It's valid to move a table across namespaces, but the server implementation is not required to support it.
     * @summary Rename a table from its current name to a new name
     * @param {RenameTableRequest} body Current table identifier to rename and new table identifier to rename to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public renameTable(body: RenameTableRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).renameTable(body, options)(this.fetch, this.basePath);
    }

    /**
     * Rename a view from one identifier to another. It's valid to move a view across namespaces, but the server implementation is not required to support it.
     * @summary Rename a view from its current name to a new name
     * @param {RenameTableRequest} body Current view identifier to rename and new view identifier to rename to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public renameView(body: RenameTableRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).renameView(body, options)(this.fetch, this.basePath);
    }

    /**
     * Commit updates to a view.
     * @summary Replace a view
     * @param {CommitViewRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public replaceView(body: CommitViewRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).replaceView(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send a metrics report to this endpoint to be processed by the backend
     * @param {ReportMetricsRequest} body The request containing the metrics report to be sent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public reportMetrics(body: ReportMetricsRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).reportMetrics(body, options)(this.fetch, this.basePath);
    }

    /**
     * Check if a table exists within a given namespace. The response does not contain a body.
     * @summary Check if a table exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public tableExists(options?: any) {
        return CatalogAPIApiFp(this.configuration).tableExists(options)(this.fetch, this.basePath);
    }

    /**
     * Set and/or remove properties on a namespace. The request body specifies a list of properties to remove and a map of key value pairs to update. Properties that are not in the request are not modified or removed by this call. Server implementations are not required to support namespace properties.
     * @summary Set or remove properties on a namespace
     * @param {UpdateNamespacePropertiesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public updateProperties(body: UpdateNamespacePropertiesRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).updateProperties(body, options)(this.fetch, this.basePath);
    }

    /**
     * Commit updates to a table.  Commits have two parts, requirements and updates. Requirements are assertions that will be validated before attempting to make and commit changes. For example, `assert-ref-snapshot-id` will check that a named ref's snapshot ID has a certain value. Server implementations are required to fail with a 400 status code if any unknown updates or requirements are received.  Updates are changes to make to table metadata. For example, after asserting that the current main ref is at the expected snapshot, a commit may add a new child snapshot and set the ref to the new snapshot id.  Create table transactions that are started by createTable with `stage-create` set to true are committed using this route. Transactions should include all changes to the table, including table initialization, like AddSchemaUpdate and SetCurrentSchemaUpdate. The `assert-create` requirement is used to ensure that the table was not created concurrently.
     * @summary Commit updates to a table
     * @param {CommitTableRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public updateTable(body: CommitTableRequest, options?: any) {
        return CatalogAPIApiFp(this.configuration).updateTable(body, options)(this.fetch, this.basePath);
    }

    /**
     * Check if a view exists within a given namespace. This request does not return a response body.
     * @summary Check if a view exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogAPIApi
     */
    public viewExists(options?: any) {
        return CatalogAPIApiFp(this.configuration).viewExists(options)(this.fetch, this.basePath);
    }

}
/**
 * ConfigurationAPIApi - fetch parameter creator
 * @export
 */
export const ConfigurationAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  All REST clients should first call this route to get catalog configuration properties from the server to configure the catalog and its HTTP client. Configuration from the server consists of two sets of key/value pairs. - defaults -  properties that should be used as default configuration; applied before client configuration - overrides - properties that should be used to override client configuration; applied after defaults and client configuration  Catalog configuration is constructed by setting the defaults, then client- provided configuration, and finally overrides. The final property set is then used to configure the catalog.  For example, a default configuration property might set the size of the client pool, which can be replaced with a client-specific setting. An override might be used to set the warehouse location, which is stored on the server rather than in client configuration.  Common catalog configuration settings are documented at https://iceberg.apache.org/docs/latest/configuration/#catalog-properties  The catalog configuration also holds an optional `endpoints` field that contains information about the endpoints supported by the server. If a server does not send the `endpoints` field, a default set of endpoints is assumed: - GET /v1/{prefix}/namespaces - POST /v1/{prefix}/namespaces - GET /v1/{prefix}/namespaces/{namespace} - HEAD /v1/{prefix}/namespaces/{namespace} - DELETE /v1/{prefix}/namespaces/{namespace} - POST /v1/{prefix}/namespaces/{namespace}/properties - GET /v1/{prefix}/namespaces/{namespace}/tables - POST /v1/{prefix}/namespaces/{namespace}/tables - GET /v1/{prefix}/namespaces/{namespace}/tables/{table} - HEAD /v1/{prefix}/namespaces/{namespace}/tables/{table} - POST /v1/{prefix}/namespaces/{namespace}/tables/{table} - DELETE /v1/{prefix}/namespaces/{namespace}/tables/{table} - POST /v1/{prefix}/namespaces/{namespace}/register - POST /v1/{prefix}/namespaces/{namespace}/tables/{table}/metrics - POST /v1/{prefix}/tables/rename - POST /v1/{prefix}/transactions/commit 
         * @summary List all catalog configuration settings
         * @param {any} [warehouse] Warehouse location or identifier to request from the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(warehouse?: any, options: any = {}): FetchArgs {
            const localVarPath = `/v1/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (warehouse !== undefined) {
                localVarQueryParameter['warehouse'] = warehouse;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationAPIApi - functional programming interface
 * @export
 */
export const ConfigurationAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         *  All REST clients should first call this route to get catalog configuration properties from the server to configure the catalog and its HTTP client. Configuration from the server consists of two sets of key/value pairs. - defaults -  properties that should be used as default configuration; applied before client configuration - overrides - properties that should be used to override client configuration; applied after defaults and client configuration  Catalog configuration is constructed by setting the defaults, then client- provided configuration, and finally overrides. The final property set is then used to configure the catalog.  For example, a default configuration property might set the size of the client pool, which can be replaced with a client-specific setting. An override might be used to set the warehouse location, which is stored on the server rather than in client configuration.  Common catalog configuration settings are documented at https://iceberg.apache.org/docs/latest/configuration/#catalog-properties  The catalog configuration also holds an optional `endpoints` field that contains information about the endpoints supported by the server. If a server does not send the `endpoints` field, a default set of endpoints is assumed: - GET /v1/{prefix}/namespaces - POST /v1/{prefix}/namespaces - GET /v1/{prefix}/namespaces/{namespace} - HEAD /v1/{prefix}/namespaces/{namespace} - DELETE /v1/{prefix}/namespaces/{namespace} - POST /v1/{prefix}/namespaces/{namespace}/properties - GET /v1/{prefix}/namespaces/{namespace}/tables - POST /v1/{prefix}/namespaces/{namespace}/tables - GET /v1/{prefix}/namespaces/{namespace}/tables/{table} - HEAD /v1/{prefix}/namespaces/{namespace}/tables/{table} - POST /v1/{prefix}/namespaces/{namespace}/tables/{table} - DELETE /v1/{prefix}/namespaces/{namespace}/tables/{table} - POST /v1/{prefix}/namespaces/{namespace}/register - POST /v1/{prefix}/namespaces/{namespace}/tables/{table}/metrics - POST /v1/{prefix}/tables/rename - POST /v1/{prefix}/transactions/commit 
         * @summary List all catalog configuration settings
         * @param {any} [warehouse] Warehouse location or identifier to request from the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(warehouse?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogConfig> {
            const localVarFetchArgs = ConfigurationAPIApiFetchParamCreator(configuration).getConfig(warehouse, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConfigurationAPIApi - factory interface
 * @export
 */
export const ConfigurationAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *  All REST clients should first call this route to get catalog configuration properties from the server to configure the catalog and its HTTP client. Configuration from the server consists of two sets of key/value pairs. - defaults -  properties that should be used as default configuration; applied before client configuration - overrides - properties that should be used to override client configuration; applied after defaults and client configuration  Catalog configuration is constructed by setting the defaults, then client- provided configuration, and finally overrides. The final property set is then used to configure the catalog.  For example, a default configuration property might set the size of the client pool, which can be replaced with a client-specific setting. An override might be used to set the warehouse location, which is stored on the server rather than in client configuration.  Common catalog configuration settings are documented at https://iceberg.apache.org/docs/latest/configuration/#catalog-properties  The catalog configuration also holds an optional `endpoints` field that contains information about the endpoints supported by the server. If a server does not send the `endpoints` field, a default set of endpoints is assumed: - GET /v1/{prefix}/namespaces - POST /v1/{prefix}/namespaces - GET /v1/{prefix}/namespaces/{namespace} - HEAD /v1/{prefix}/namespaces/{namespace} - DELETE /v1/{prefix}/namespaces/{namespace} - POST /v1/{prefix}/namespaces/{namespace}/properties - GET /v1/{prefix}/namespaces/{namespace}/tables - POST /v1/{prefix}/namespaces/{namespace}/tables - GET /v1/{prefix}/namespaces/{namespace}/tables/{table} - HEAD /v1/{prefix}/namespaces/{namespace}/tables/{table} - POST /v1/{prefix}/namespaces/{namespace}/tables/{table} - DELETE /v1/{prefix}/namespaces/{namespace}/tables/{table} - POST /v1/{prefix}/namespaces/{namespace}/register - POST /v1/{prefix}/namespaces/{namespace}/tables/{table}/metrics - POST /v1/{prefix}/tables/rename - POST /v1/{prefix}/transactions/commit 
         * @summary List all catalog configuration settings
         * @param {any} [warehouse] Warehouse location or identifier to request from the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(warehouse?: any, options?: any) {
            return ConfigurationAPIApiFp(configuration).getConfig(warehouse, options)(fetch, basePath);
        },
    };
};

/**
 * ConfigurationAPIApi - object-oriented interface
 * @export
 * @class ConfigurationAPIApi
 * @extends {BaseAPI}
 */
export class ConfigurationAPIApi extends BaseAPI {
    /**
     *  All REST clients should first call this route to get catalog configuration properties from the server to configure the catalog and its HTTP client. Configuration from the server consists of two sets of key/value pairs. - defaults -  properties that should be used as default configuration; applied before client configuration - overrides - properties that should be used to override client configuration; applied after defaults and client configuration  Catalog configuration is constructed by setting the defaults, then client- provided configuration, and finally overrides. The final property set is then used to configure the catalog.  For example, a default configuration property might set the size of the client pool, which can be replaced with a client-specific setting. An override might be used to set the warehouse location, which is stored on the server rather than in client configuration.  Common catalog configuration settings are documented at https://iceberg.apache.org/docs/latest/configuration/#catalog-properties  The catalog configuration also holds an optional `endpoints` field that contains information about the endpoints supported by the server. If a server does not send the `endpoints` field, a default set of endpoints is assumed: - GET /v1/{prefix}/namespaces - POST /v1/{prefix}/namespaces - GET /v1/{prefix}/namespaces/{namespace} - HEAD /v1/{prefix}/namespaces/{namespace} - DELETE /v1/{prefix}/namespaces/{namespace} - POST /v1/{prefix}/namespaces/{namespace}/properties - GET /v1/{prefix}/namespaces/{namespace}/tables - POST /v1/{prefix}/namespaces/{namespace}/tables - GET /v1/{prefix}/namespaces/{namespace}/tables/{table} - HEAD /v1/{prefix}/namespaces/{namespace}/tables/{table} - POST /v1/{prefix}/namespaces/{namespace}/tables/{table} - DELETE /v1/{prefix}/namespaces/{namespace}/tables/{table} - POST /v1/{prefix}/namespaces/{namespace}/register - POST /v1/{prefix}/namespaces/{namespace}/tables/{table}/metrics - POST /v1/{prefix}/tables/rename - POST /v1/{prefix}/transactions/commit 
     * @summary List all catalog configuration settings
     * @param {any} [warehouse] Warehouse location or identifier to request from the service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationAPIApi
     */
    public getConfig(warehouse?: any, options?: any) {
        return ConfigurationAPIApiFp(this.configuration).getConfig(warehouse, options)(this.fetch, this.basePath);
    }

}
/**
 * OAuth2APIApi - fetch parameter creator
 * @export
 */
export const OAuth2APIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The `oauth/tokens` endpoint is **DEPRECATED for REMOVAL**. It is _not_ recommended to implement this endpoint, unless you are fully aware of the potential security implications. All clients are encouraged to explicitly set the configuration property `oauth2-server-uri` to the correct OAuth endpoint. Deprecated since Iceberg (Java) 1.6.0. The endpoint and related types will be removed from this spec in Iceberg (Java) 2.0. See [Security improvements in the Iceberg REST specification](https://github.com/apache/iceberg/issues/10537)  Exchange credentials for a token using the OAuth2 client credentials flow or token exchange.  This endpoint is used for three purposes - 1. To exchange client credentials (client ID and secret) for an access token This uses the client credentials flow. 2. To exchange a client token and an identity token for a more specific access token This uses the token exchange flow. 3. To exchange an access token for one with the same claims and a refreshed expiration period This uses the token exchange flow.  For example, a catalog client may be configured with client credentials from the OAuth2 Authorization flow. This client would exchange its client ID and secret for an access token using the client credentials request with this endpoint (1). Subsequent requests would then use that access token.  Some clients may also handle sessions that have additional user context. These clients would use the token exchange flow to exchange a user token (the \"subject\" token) from the session for a more specific access token for that user, using the catalog's access token as the \"actor\" token (2). The user ID token is the \"subject\" token and can be any token type allowed by the OAuth2 token exchange flow, including a unsecured JWT token with a sub claim. This request should use the catalog's bearer token in the \"Authorization\" header.  Clients may also use the token exchange flow to refresh a token that is about to expire by sending a token exchange request (3). The request's \"subject\" token should be the expiring token. This request should use the subject token in the \"Authorization\" header.
         * @summary Get a token using an OAuth2 flow (DEPRECATED for REMOVAL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(options: any = {}): FetchArgs {
            const localVarPath = `/v1/oauth/tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            // authentication OAuth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2", ["catalog"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2APIApi - functional programming interface
 * @export
 */
export const OAuth2APIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The `oauth/tokens` endpoint is **DEPRECATED for REMOVAL**. It is _not_ recommended to implement this endpoint, unless you are fully aware of the potential security implications. All clients are encouraged to explicitly set the configuration property `oauth2-server-uri` to the correct OAuth endpoint. Deprecated since Iceberg (Java) 1.6.0. The endpoint and related types will be removed from this spec in Iceberg (Java) 2.0. See [Security improvements in the Iceberg REST specification](https://github.com/apache/iceberg/issues/10537)  Exchange credentials for a token using the OAuth2 client credentials flow or token exchange.  This endpoint is used for three purposes - 1. To exchange client credentials (client ID and secret) for an access token This uses the client credentials flow. 2. To exchange a client token and an identity token for a more specific access token This uses the token exchange flow. 3. To exchange an access token for one with the same claims and a refreshed expiration period This uses the token exchange flow.  For example, a catalog client may be configured with client credentials from the OAuth2 Authorization flow. This client would exchange its client ID and secret for an access token using the client credentials request with this endpoint (1). Subsequent requests would then use that access token.  Some clients may also handle sessions that have additional user context. These clients would use the token exchange flow to exchange a user token (the \"subject\" token) from the session for a more specific access token for that user, using the catalog's access token as the \"actor\" token (2). The user ID token is the \"subject\" token and can be any token type allowed by the OAuth2 token exchange flow, including a unsecured JWT token with a sub claim. This request should use the catalog's bearer token in the \"Authorization\" header.  Clients may also use the token exchange flow to refresh a token that is about to expire by sending a token exchange request (3). The request's \"subject\" token should be the expiring token. This request should use the subject token in the \"Authorization\" header.
         * @summary Get a token using an OAuth2 flow (DEPRECATED for REMOVAL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OAuth2APIApiFetchParamCreator(configuration).getToken(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OAuth2APIApi - factory interface
 * @export
 */
export const OAuth2APIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The `oauth/tokens` endpoint is **DEPRECATED for REMOVAL**. It is _not_ recommended to implement this endpoint, unless you are fully aware of the potential security implications. All clients are encouraged to explicitly set the configuration property `oauth2-server-uri` to the correct OAuth endpoint. Deprecated since Iceberg (Java) 1.6.0. The endpoint and related types will be removed from this spec in Iceberg (Java) 2.0. See [Security improvements in the Iceberg REST specification](https://github.com/apache/iceberg/issues/10537)  Exchange credentials for a token using the OAuth2 client credentials flow or token exchange.  This endpoint is used for three purposes - 1. To exchange client credentials (client ID and secret) for an access token This uses the client credentials flow. 2. To exchange a client token and an identity token for a more specific access token This uses the token exchange flow. 3. To exchange an access token for one with the same claims and a refreshed expiration period This uses the token exchange flow.  For example, a catalog client may be configured with client credentials from the OAuth2 Authorization flow. This client would exchange its client ID and secret for an access token using the client credentials request with this endpoint (1). Subsequent requests would then use that access token.  Some clients may also handle sessions that have additional user context. These clients would use the token exchange flow to exchange a user token (the \"subject\" token) from the session for a more specific access token for that user, using the catalog's access token as the \"actor\" token (2). The user ID token is the \"subject\" token and can be any token type allowed by the OAuth2 token exchange flow, including a unsecured JWT token with a sub claim. This request should use the catalog's bearer token in the \"Authorization\" header.  Clients may also use the token exchange flow to refresh a token that is about to expire by sending a token exchange request (3). The request's \"subject\" token should be the expiring token. This request should use the subject token in the \"Authorization\" header.
         * @summary Get a token using an OAuth2 flow (DEPRECATED for REMOVAL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(options?: any) {
            return OAuth2APIApiFp(configuration).getToken(options)(fetch, basePath);
        },
    };
};

/**
 * OAuth2APIApi - object-oriented interface
 * @export
 * @class OAuth2APIApi
 * @extends {BaseAPI}
 */
export class OAuth2APIApi extends BaseAPI {
    /**
     * The `oauth/tokens` endpoint is **DEPRECATED for REMOVAL**. It is _not_ recommended to implement this endpoint, unless you are fully aware of the potential security implications. All clients are encouraged to explicitly set the configuration property `oauth2-server-uri` to the correct OAuth endpoint. Deprecated since Iceberg (Java) 1.6.0. The endpoint and related types will be removed from this spec in Iceberg (Java) 2.0. See [Security improvements in the Iceberg REST specification](https://github.com/apache/iceberg/issues/10537)  Exchange credentials for a token using the OAuth2 client credentials flow or token exchange.  This endpoint is used for three purposes - 1. To exchange client credentials (client ID and secret) for an access token This uses the client credentials flow. 2. To exchange a client token and an identity token for a more specific access token This uses the token exchange flow. 3. To exchange an access token for one with the same claims and a refreshed expiration period This uses the token exchange flow.  For example, a catalog client may be configured with client credentials from the OAuth2 Authorization flow. This client would exchange its client ID and secret for an access token using the client credentials request with this endpoint (1). Subsequent requests would then use that access token.  Some clients may also handle sessions that have additional user context. These clients would use the token exchange flow to exchange a user token (the \"subject\" token) from the session for a more specific access token for that user, using the catalog's access token as the \"actor\" token (2). The user ID token is the \"subject\" token and can be any token type allowed by the OAuth2 token exchange flow, including a unsecured JWT token with a sub claim. This request should use the catalog's bearer token in the \"Authorization\" header.  Clients may also use the token exchange flow to refresh a token that is about to expire by sending a token exchange request (3). The request's \"subject\" token should be the expiring token. This request should use the subject token in the \"Authorization\" header.
     * @summary Get a token using an OAuth2 flow (DEPRECATED for REMOVAL)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2APIApi
     */
    public getToken(options?: any) {
        return OAuth2APIApiFp(this.configuration).getToken(options)(this.fetch, this.basePath);
    }

}
